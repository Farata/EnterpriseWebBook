:toc:
:toclevels: 4

== Hybrid Mobile Applications

The word http://www.thefreedictionary.com/hybrid[hybrid] means something of mixed origin or composition. In case of mobile applications such a mix consists of the the code written in HTML5, which may also access the APIs written in native languages. If an organization doesn't want or can't afford hiring separate teams of experts (e.g Objective-C developers for iPhone, Java for Android, C# for Windows Phone, et al) there is a way to have one team with HTML/JavaScript skills that will develop applications haveing the same code, but deployed on various mobile devices packaged as native applications. The next two sections should give you a bit more of the information comparing native vs. Web vs. hybrid mobile applications.


=== Native Applications

We call a mobile application _native_ if it was not written in HTML/JavaScript, but rather in a programming language recommended for devices of this mobile platform. The manufacturer of the mobile devices makes an SDK available for software developers and describes a process of creating native applications. Such SDK provides API for accessing all components (both hardware and software) of the mobile device such as phone, contact list, camera, microphone and others. Such SDKs include UI components that have a _native look and feel_, so applications developed by third parties look the same as those developed by the device manufacturer.

Native applications can seamlessly communicate with each other. They can use all available hardware and software components of the device to create convenient workflows that people like and quickly get accustomed too. For example, a person can take a picture with her mobile phone, which automatically figures out the geographical location and allows to share the photo with other people from the person's contact's list. The native application that supports such functionality has to have access to the camera of the mobile's device, figure out the device coordinates, and have programmatic access to the Contacts application. 

If you are in the business of writing mobile flight simulators or games that heavily rely on graphics (not a Sudoku type of games) - select a programming language that can use the device hardware (e.g. graphic accellerators) to its fullest.

For native applications, a device manufacturer usually offers an _application store_, which serves as an online market place where people would shop for applications. Apple has the _App Store_ for iOS and OS X applications. Google has _Google play_ for Android applications. _BlackBerry World_ is a store where you can find applications for mobile devices manufactured by RIM. Microsoft has their store too. 

There are more application stores available, and having a market place (a one stop shop) is really important for consumer-oriented application developers. For enterprise applications, having public distribution channel may be less important, but enterprises need a way to publish mobile applications for private use. 

Apple has https://developer.apple.com/programs/ios/enterprise/[iOS Developer Enterprise Program]. For Android applications, there is a http://support.google.com/a/bin/answer.py?hl=en&answer=2494992[Google Play Private Channel] for internal distribution channels. Microsoft has http://www.windowsphone.com/en-US/business/for-business[their process] for business applications too.

NOTE: We already mentioned that hybrids are developed in JavaSript/HTML for different mobile platforms. But there is a way to develop native mobile applications in the same language for multiple platforms. With http://xamarin.com/[Xamarin] you can develop applications in C# for iOS, Android and Windows Phone.   

==== Native vs. Web Applications

Both Web and native applications have their pros and cons. The latter are usually faster than Web applications. Let's mention some of the examples of native mobile business applications that exist today. 

Bank of America's native mobile application allows you to deposit a check by taking a photo of the front and back sides of the check and entering the amount. At the time of this writing, they support iPhones, Android, Windows phones, and iPads. Other major banks offers similar service too.

Near Field Communication (NFC) technology allows NFC-enabled devices communicate with each other in close distance using radio frequencies. NFC can be used for payments (no need to enter passwords) and data sharing (contacts, photos, et al.) Proliferation of NFC in banking will seriously hurt the credit cards industry. A number of smartphones already support NFC technology (see http://www.nfcworld.com/nfc-phones-list/[http://www.nfcworld.com/nfc-phones-list]). Add one of the existing fingerprint biometrics solutions, and your mobile phone becomes your wallet. 

While native applications have full access to all the native APIs of the mobile device (e.g. contacts, camera, microphone, et al.), they have drawbacks too. For instance, if you want to publish your application at Apple's App Store you have to submit your application in advance and wait for an approval. If the users run into a crucial bug in your application, even if it can be fixed in a day, you can't put a new version in production until it goes through an approval process. Beside such workflow inconveniences, there can be other road blocks. For instance, back in 2011 Financial Times (FT) decided to stop using their native iOS application because Apple wouldn't agree to share the data about FT subscribers with FT - the owner of this application. Don't forget that Apple get their own cut from each FT subscription. 

Mobile Web applications don't require any third-party involvement for the distribution. An enterprise can make them available at any time by simple adding a Download button on the corporate Web site. It's good to have an ability to quickly publish the latest versions Web applications on your own servers without the need to ask for a permission. On the other hand, maintaining the presence on one of the popular app stores or mobile markets is a good channel for bringing new customers. 

The publisher of New York magazine is heavily investing into their native application for iPad, but the newer versions of their Web applications are as engaging as their native piers. If your Web application need to be discoverable and visible by search engines, Web applications are definitely better.

=== Hybrid Applications

_Hybrid applications_ promise you to have the best of both worlds. Develop a Web application in HTML/JavaScript, but access the native API of the mobile device via third-party solutions such as http://phonegap.com/[PhoneGap] from Adobe or http://www.appcelerator.com/platform/titanium-platform/[Titanium] from Appcelerator (the company behind Aptana Studio). 

http://cordova.apache.org/[Cordova] is a library (and a build tool) that serves as a bridge between JavaScript and native API. Cordova started from the code donated by Adobe to Apache Software Foundation. has an open source platform called  for building native mobile applications with HTML5. PhoneGap is a brand own by Adobe. It includes a packager and a build tool based on Cordova. Lots of developers from around the world work on Cordova, but Adobe's use this library to create their own workflow of compiling and distributing mobile applications.  The closest analogy is the Chrome and Safari browsers built on the same open source rendering engine Webkit.  Figure <<FIG14-1>> illustrates the interaction of  PhoneGap, Cordova, and Web applications. 

[[FIG14-1]]
.PhoneGap, Cordova and Web Applications
image::images/fig_14_01.png[] 

PhoneGap is a set of APIs and a workflow for creating _an application container_ with your Web application written in  HTML5 (with or without frameworks) that also allows to make JavaScript calls to access native API offered by the mobile OS. 

https://build.phonegap.com/[PhoneGap Build] is a cloud service, where you upload your  HTML/JavaScript/CSS code. Then PhoneGap Build compiles it for multiple mobile platforms and creates several native applications - one per platform. Each application is a wrapper with embedded chrome-less Web browser ( a.k.a. Web View) that looks native to the mobile OS, and has access to various native APIs. Refer to http://docs.phonegap.com/en/3.0.0/index.html[PhoneGap documentation] to see what APIs are supported on each mobile platform. The native wrapper serves as a messaging bus between the external native API and HTML-based applications running inside the Web view. 

If you need to build an application to run under iOS, PhoneGap Build will create an .ipa file. For deployment on Android devices you'd be getting a .apk file. After that, if you want to submit your application to a public or private application store, follow the procedure that exists for native applications for the selected store. The PhoneGap Build service can package your application for iOS, Android, Windows Phone, Blackberry, and other platforms.

PhoneGap applications might be a little slower comparing to the native ones. The reason being that there is a Web View (a Web brenderer) between the application code and the device API. The older versions of mobile OS may have slower Web rendering engines, but for the majority of enterprise applications the difference may not by noticeable. Developers are encouraged to use best practices recommended for any HTML-based applications. 

UI components of the HTML5 framework of your choice may not look native enough too. The selling point is that PhoneGap allows you to leverage existing HTML/JavaScript developers' skills for all major mobile platforms, and their native API is easy to learn. 

Titanium offers its own set of tools and more extensive API. You'd be writing code in JavaScript (no HTML or CSS) and would need to learn The compiled and deployed application is a JavaScript embedded inside Java or Objective-C code plus JavaScript interpreter plus platform-specific Titanium API. The JavaScript objects talk to it's native Titanium piers via proxies. There is not Web view rendering here - the JavaScript code is evaluated by the embedded interpreter, but UI components are from Titanium itself.

Titanium UI components can be extended to use native OS interface abilities to their fullest. But if you want to go this route, why not writing the entire application natively? Besides, as new platform will be introduced, you'll depend on the willingness of the Titanium developers to create a new set of components in a timely fashion.  

You can't expect high performance from the Rhino JavaScript engine, which is used for Android and Blackberry applications. The latest JavaScript engine from Oracle is called Nashorn, but it's available only for the very latest Java version, which doesn't run on Android, and will not run in the foreseeable future. Nashorn is as fast as http://v8.googlecode.com/svn/data/benchmarks/v7/run.html[Google's V8], but Rhino is  slower. Does it mean that Titanium applications on Android and Blackberry will alway run slower? It seems to be the case unless Oracle and Google will find a way to stop their quarrel around Java. 

The learning curve of the Titanium API is steeper than with PhoneGap.  

NOTE: PhoneGap and Titanium are not the only solutions that allow building hybrid applications using HTML5. The framowork http://www.kendoui.com/mobile.aspx[Kendo UI Mobile] can build hybrid applications for iOS, Android, Blackberry, and Window Phone 8. The http://developers.mobile.conduit.com/reference/documentation/overview/introduction.aspx[Mobile Conduit API] allows to build cross-platform mobile application with HTML5. http://www.convertigo.com/[Convertigo Mobilizer] is a cross-platform enterprise mashup environment that incorporates PhoneGap and Sencha Touch for building mobile applications. http://www-03.ibm.com/software/products/us/en/worklight/[IBM Woklight] offers to enterprises a client/server/cloud to enterprises develop, test, run and manage HTML5, hybrid and native mobile applications.

If a particular enterprise application will be used only internally by people who use limited variety of mobile devices, and if making these people productive is the main goal - develop native applications. Start with developing and deploying such the first application for the pilot mobile OS (typically for the latest iOS or Android OS), and then gradually add support for more  platforms, budget permitting. If you are planning to develop a Web application with relatively simple UI (as in Save Sick Child) and have to support a wide variety of unknown consumer devices (e.g. you want to  enable people to donate from any device) - develop an HTML5 Web application. 

Consider developing a hybrid application for anything in between, and in this chapter we'll create a hybrid version of our Save Sick Child application with http://phonegap.com/[PhoneGap] framework. To be more specific, we'll access the camera of the smartphone.

=== Intro to the PhoneGap Workflows

After cordova library is installed on the developer's computer, PhoneGap 3.0 offers two major workflows. Each of the following workflows will allow you to build a mobile application, but the main difference is where you build the application - either locally or remotely:

1. Install all required mobile SDKs and tools for the mobile platforms you want to develop, generate the initial project using Cordova CLI, add the application code, build locally, and test the application using IDE, simulators and phisical devices.  

2. Don't install any mobile SDK and tools. Just generate the initial project using Cordova CLI, add the application code, zip up the _www_ folder and upload it to https://build.phonegap.com/[Adobe PhoneGap Build] server, which will build the applicaion for all platforms. Then download and and test the application using physical devices.

The second workflow requires running a trivial install of cordova and then you just trust the Build PhoneGap server to do the proper build for you. The first one is more involved, and we'll illustrate it by showing how to use the local SDKs for iOS deployment. 

In any case you'll need to install cordova according to the instructions for http://docs.phonegap.com/en/3.0.0/guide_cli_index.md.html#The%20Command-line%20Interface [the command-line interface]. Start with installing Node.js, which will also install its package manager _npm_ used for installing cordova (and phonegap library). We're developing on MAC OS X, and here's the command that will install cordova: 

_sudo npm install -g cordova_

// Using 3.0 CLI http://blog.safaribooksonline.com/2013/07/19/streamline-cross-platform-development-using-apache-cordova-phonegap-cli/

The above command installs the JavaScript file _cordova_ in _/usr/local/bin_ and the cordova library and its supporting files in the _/usr/local/lib/node_modules/cordova_ - Figure <<FIG14-2>> shows the snapshot of some of the files and diresctories that come with cordova. We've highlighted the create.js script, which will be used for generating Hello World and Save Sick Child projects. 


[[FIG14-2]]
.Cordova 3.0 Installed
image::images/fig_14_02.png[]

In this chapter we'll be developing sample applications for iOS platform, to illustrate the most complex deployment-deployment cycle. It requires https://developer.apple.com/xcode/[Xcode IDE], which is available at Apple's App Store at no charge. After installing Xcode open its menu Preferences and install Command Line Tools (CLT) from the Downloads panel. By default, Xcode comes with the latest iOS simulator, which is version 6.1 at the time of this writing. 

==== Hello World

It's time for the PhoneGap Hello World. We are going to generate the initial project using  Cordova command line interface (CLI) as described in the same http://docs.phonegap.com/en/3.0.0/guide_cli_index.md.html#The%20Command-line%20Interface[document] we used for installing cordova in the section titled "Create the App". We'll be running the _cordova_ script passing it the command _create_:

_sudo cordova create HelloWorld com.example.hello "Hello World"_

After generating Hello World with _cordova create_ command Cordova CLI creates files and directories shown on Figure <<FIG14-3>>. 
 

[[FIG14-3]]
.Cordova-generated project Hello World
image::images/fig_14_03.png[] 

NOTE: If you used the command exactly as it shown in the documentation _cordova create HelloWorld com.example.hello "Hello World"_, keep in mind that when you'll be creating the certificate to run it on the iOS device, it has to be valid for applications packages in com.example. For more details see the sidebar "Testing Application on iOS Devices" later in this chapter.

The content of generated index.html is shown next. It includes several meta tags to use the entire screen of the mobile device and don't allow scaling by user's gestures. Then it includes a couple of JavaScript files. 

[source, html]
----
<!DOCTYPE html>
<html>
 <head>
     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
     <meta name = "format-detection" content = "telephone=no"/>
     <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width;" />
     <link rel="stylesheet" type="text/css" href="css/index.css" />
     <title>Hello Cordova</title>
 </head>
 <body>
     <div class="app">
         <h1>Apache Cordova</h1>
         <div id="deviceready">
             <p class="status pending blink">Connecting to Device</p>
             <p class="status complete blink hide">Device is Ready</p>
         </div>
     </div>
     <script type="text/javascript" src="cordova.js"></script>
     <script type="text/javascript" src="js/index.js"></script>
     <script type="text/javascript">
         app.initialize();
     </script>
 </body>
</html>
----

This HTML includes the code to load the cordova.js library and the initialization code from index.js, and then immediately calls `app.initialize()`. But if you look at <<FIG14-3>> the file cordova.js is missing. Cordova CLI will add it to the project during the next phase of code generation when you'll run the command _cordova platform add_ to add specific mobile platforms to your project. For now, let's look at the code of the index.js.

[source, javascript]
----
var app = {
  initialize: function() {                       // <1>
      this.bind();
  },

  bind: function() {
    document.addEventListener('deviceready',     // <2>
               this.deviceready, false);
  },

  deviceready: function() {
    
    app.report('deviceready');
  },

  report: function(id) {                        //  <3>

      console.log("report:" + id);
      
      document.querySelector('#' + id + ' .pending').className += ' hide';
      var completeElem = document.querySelector('#' + id + ' .complete');
      completeElem.className = completeElem.className.split('hide').join('');
  }
};
----

<1> This function is being called when all scripts are loaded in index.html.

<2> The mobile OS sends the `deviceready` event to the PhoneGap application when it's ready to invoke native APIs.

<3> The function `report()` is called from the `deviceready` event handler. It hides the `.pending <p>` and shows the `.complete <p>` in index.html. Technically, `split('hide')` followed by `join('')` perform removal of the word hide.

WARNING: It's not too difficult to prepare such simple HTML and JavaScript files manually, but we prefer using code generators - they are faster and less error prone. 

According some Cordova CLI documentation after the code is generated you need to add the platforms for which you are planning to prepare PhoneGap builds. For example, you can run the following commands from the Terminal window (inside the HelloWorld directory) to request the builds for ios, android, and blackberry:

_cordova platform add ios_

_cordova platform add android_

NOTE: The first command will run fine, because we have Xcode installed. The second command will be giving you errors until you install the latest Android SDK as described in the sidebar. There are two ways of working with PhoneGap applications: either you install required SDKs and prepare the builds locally, or develop an application for one platform and send it to the PhoneGap Build server that will create multiple builds for different platforms. The  description of the workflow with the Build Phonegap server will follow.

After running these commands, the initially empty directory _platforms_ will be filled with additional sub-directories specific to each platform. Technically, these commands generate separate Hello World projects - one per platform. Each of them will have its own _www_ directory with index.html and cordova.js that was missing during the initial project generation. You can see on Figure <<FIG14-4>> the content of the ios folder that was generated as a result of executing command _cordova platform add ios_.

[[FIG14-4]]
.Cordova-generated project for iOS platform
image::images/fig_14_04.png[] 

Double-click on the file Hello_World.xcodeproj, and Xcode will open it as a project. Press the button Run on the top left corner of the toolbar to compile the project and start in the iOS simulator (see Figure <<FIG14-4-1>>). Note the "Device is ready" text from index.html (as per index.css this text is blinking and is shown in the upper case).

[[FIG14-4-1]]
.Running Hello World in XCode
image::images/fig_14_04_1.png[] 

.Testing Applications on iOS Devices
*******
If you want to test your application not in the simulator, but  on the physical iOS device, it has to be connected to your Mac computer, enabled for deployment and recognized by Apple. Details on _provisioning your devices for development_ are described in the online http://developer.apple.com/library/ios/#documentation/ToolsLanguages/Conceptual/YourFirstAppStoreSubmission/ProvisionYourDevicesforDevelopment/ProvisionYourDevicesforDevelopment.html[iOS Developer Library]. If you prefer shorter instructions, here's what worked for us:

1. Open a Keychain Access application on your Mac computer and create a certificate request using the menus Keychain Access | Certificate Assistant | Request a Certificate from Certificate Authority. This will create a file with the name extension .certSigningRequest.

2. Log on to Member Center at https://developer.apple.com[developer.apple.com] and create a certificate in there for iOS Development specifying the wildcard (an asterisk) in the Bulk name unless you want to restrict this certificate to be used only with application that start with a certain prefix. During this step you'll need to upload the .certSigningRequest file created in the previous step. 

3. After this certificate is created, download this file (its  name ends with .cer), and double-click on it to open in your local keychain. Find it in the list of certificates and expand it - it should include the private key. 

4. Remain in the Member Center, and create a unique application ID.

5. Finally, in the same Member Center create a Provisioning Profile.     

6. In Xcode, open the menu Window | Organizer, go to Provisioning profiles window, and refresh it. You should see the newly created provisioning profile marked with a green bullet. A physical file with the name extension .mobileprovision correspond to this profile.

7. Select your iOS device in the active scheme dropdown on top left and run your Hello World or other project on the connected device.
*******

TIP: Read Apple's https://developer.apple.com/library/mac/#documentation/IDEs/Conceptual/AppDistributionGuide/Introduction/Introduction.html[App Distribution Guide] to learn how to distribute your iOS applications.

// Tech support doc: https://developer.apple.com/search/index.php?q=tn2250

.Installing more local SDKs
******

As we stated earlier, you don't have to install SDK's locally, but if you decided to do so, consult with instructions by the respective mobile platform vendor. For example, Blackberry developers can download their WebWorks SDK at http://developer.blackberry.com/html5/download/[developer.blackberry.com/html5/download] as well as BLackBerry 10 Simulator.If you haven't downloaded the Ripple Emulator (see Chapter 12) you can get it there too. 

Instructions for installing the Windows Phone SDK are available at the http://dev.windowsphone.com/en-us/downloadsdk[Windows Phone Dev Center].

To get Android SDK, go to http://developer.android.com/sdk[android.com/sdk]. We are going to do a simple install by pressing the button "Download the SDK ADT Bundle for Mac", which will download and install Eclipse IDE with ADT plugin, Android SDK tools, Android Platform tools, and Android platform. But if you already have Eclipse IDE and prefer to install and configure required tooling manually, follow the instructions published on this Web site under the section "Use and Existing IDE". 

After downloading the bundle, unzip this file, and it'll create a folder with two subfolders: _sdk_ and _eclipse_. Start Eclipse IDE from _eclipse_ folder accepting the location of the default workspace. Press the little Plus sign on the top toolbar and open perspective DDMS. This is the place where you can use Android emulator while developing Android applications.
******

=== Using Adobe PhoneGap Build Service

Instead of installing multiple SDKs for different platforms you can use the cloud service https://build.phonegap.com/[Adobe PhoneGap Build], which already has installed and configured all supported SDK's and will do a build of your application for different platforms.

Visit build.phonegap.com and sign in with your Adobe or Github ID. If your project resides on Github, copy its URL to the text field shown on Figure <<FIG14-4-2>>. The other way to do a build is to compress your project's _www_ directory and upload this zip file there.

NOTE: Starting from PhoneGap 3.0 all code modification are done in the main _www_ folder of your project. During local rebuilds of the project all the changes get automatically replicated to each installed platfotm's _www_ folder. 

[[FIG14-4-2]]
.Submitting Application to PhoneGapBuild
image::images/fig_14_04_2.png[]

Before zipping up Hello World's  _www_ directory, open and modify the file config.xml. The generated XML contains a lot of non-related to iOS entries. All of the lines that contain the words _android_ or _blackberry_ should be removed. 

[source, xml]
----
<?xml version='1.0' encoding='utf-8'?>
<widget id="com.example.hello" version="2.0.0" 
        xmlns="http://www.w3.org/ns/widgets" 
        xmlns:cdv="http://cordova.apache.org/ns/1.0">
    
    <name>Hello World</name>
    
    <description>
        A sample Apache Cordova application that responds to the deviceready event.
    </description>
    
    <author email="callback-dev@incubator.apache.org" href="http://cordova.io">
        Apache Cordova Team
    </author>
    
    <icon height="512" src="res/icon/cordova_512.png" width="512" />
    <icon cdv:platform="ios" height="144" src="res/icon/cordova_ios_144.png" width="144" />
    <cdv:splash cdv:platform="ios" height="748" src="res/screen/ipad_landscape.png" width="1024" />
    <cdv:splash cdv:platform="ios" height="1004" src="res/screen/ipad_portrait.png" width="768" />
    <cdv:splash cdv:platform="ios" height="1496" src="res/screen/ipad_retina_landscape.png" width="2048" />
    <cdv:splash cdv:platform="ios" height="2008" src="res/screen/ipad_retina_portrait.png" width="1536" />
    <cdv:splash cdv:platform="ios" height="320" src="res/screen/iphone_landscape.png" width="480" />
    <cdv:splash cdv:platform="ios" height="480" src="res/screen/iphone_portrait.png" width="320" />
    <cdv:splash cdv:platform="ios" height="640" src="res/screen/iphone_retina_landscape.png" width="960" />
    <cdv:splash cdv:platform="ios" height="960" src="res/screen/iphone_retina_portrait.png" width="640" />
    
    <feature name="http://api.phonegap.com/1.0/device" />
    
    <preference name="phonegap-version" value="2.9.0" />
    <access origin="*" />
</widget>

----

Specify the latest _supported_ Phonegap version in the "phonegap-version" attribute. The online document https://build.phonegap.com/docs/config-xml[Using config.xml] has the information about supported versions and other essential properties. We'll change the phonegap-version value to 2.9.0, which is the latest supported by PhoneGap Build version. You'll see some other entries in config.xml of the Save Sick Child application.

Now you select all the content inside the _www_ folder and compress it into the zip file named helloworld-build.zip. Go to build.phonegap.com and press the button labeled "Upload a .zip file" and select helloworld-build.zip. When uploading is done, you'll see a next screen shown at <<FIG14-4-3>>. 

[[FIG14-4-3]]
.After helloworld-build.zip was uploaded
image::images/fig_14_04_3.png[]

Click on the button Ready to Build, and the build for all available platform will start. In you did everything right, after watching the wait cursor on above each icon, the builds will successfully complete, and you'll see a blue line under each button. Figure <<FIG14-4-4>> illustrates the case when the build failed for iOS and BlackBerry platforms (the first and fourth buttons are underlined in red color). 

Fixing the BlackBerry version of the application is not in our agenda. Refer to http://docs.phonegap.com/en/edge/guide_platforms_index.md.html[Platform Guides] documentation that contain specific information on what has to be done to develop and deploy PhoneGap applications for each platform. We'll just take care of the iOS issue.

[[FIG14-4-4]]
.Two builds failed
image::images/fig_14_04_4.png[]

After clicking on the iOS button, it revealed the message in a dropdown box "No key selected". Another error message reads"You must provide the signing key first". The dropdown also offers an option to add the missing key. Selecting this option reveals a panel shown on Figure <<FIG14-4-5>>.

[[FIG14-4-5]]
.Uploading certificate and profile
image::images/fig_14_04_5.png[]

The missing key message actually means that they need the provisioning profile and certificate discussed in the section "Testing Applications on iOS Devices". The certificate has to be in the P12 format, and you can export it into the .p12 file from the Keychain Access program. During the export, you'll assign a password to the certificate that will be required by PhoneGap Build process. After uploading the .p12 and .mobileprovision to PhoneGap Build and unlocking the little yellow lock, rebuild the Hello World for iOS and it should be done without any errors this time.  

TIP: If you forgot where the .mobileprovision file is located, open Xcode and got to the menu Window | Organize, open the panel Provisioning Profiles under Library, right-click on the profile record and select Reveal in Finder.  

To complete the process, we need to distribute and deploy the application on your mobile device. There are two ways to do this. The first one is by using http://en.wikipedia.org/wiki/QR_code[QR Code] that was generated specifically for our application as shown on the right side of Figure <<FIG14-4-4>>. Just install the QR Reader application on your device, scan this code and the application will be installed.

If you prefer to physically copy the applicaton file on the devices, download it from build.phonegap.com to your computer and then copy it on the mobile device. For example, to get the Android version of Hello World, just click on the button with Androids logo and the file HelloWorld-debug.apk will be downloaded to your computer. Copy this file to your Android device and enjoy the application. For the iOS version, click on the button with the iOS logo, which will download the file HelloWorld.ipa on your Mac computer. Double click on this file in Finder, and it'll bring it into the Application section of iTunes. Synchronize the the content of iTunes with the iOS device, and Hello World will be installed there. 

NOTE: Using PhoneGap Build service is free as long as you're building public applications, which have their source code hosted on a publicly accessible HitHub repository. Our Hello World application is considered to be a private one because we submitted it to PhoneGap Build in a zip file (not the _private_ tab in Figure <<FIG14-4-2>>). Only one private application at a time can be built for free with PhoneGap Build service. For building multiple private applications you'd need to purchase an inexpensive subscribtion from Adobe. To replace one application with the other, click on it's name, then press the button Settings and the button Delete this App. 

Phew! This was the longest description of developing and deploying the Hello World application not only in this book, but that we've ever written!  Of course, we picked deployment on the Apple's devices, which this the most complicated process among mobile developers. And we didn't even cover the process of submission the application in the App Store (you'll read more about it in the next section)! But developing and deploying application that have to run natively on multiple platforms is expected to be more complicated that deploying an HTML5 application in a Web browser. 

//TIP: Members of PhoneGap community can develop their own plugins for entire community to use. You can find details in this http://phonegap.com/blog/2013/07/15/using-plugins-with-phonegapbuild/[blog of Mike Harris]. 


TIP: Instead of using JavaScript function `alert()`, display messages using `navigator.notification.alert()` and PhoneGap will show them using a native message box for each mobile platform. The `Notification` object also supports `confirm()`, `beep()`, and `vibrate()` methods.

//TIP: For current list of available PhoneGap plugins for various mobile platforms visit the github repository at https://github.com/phonegap/phonegap-plugins[https://github.com/phonegap/phonegap-plugins].


==== Distribution of Mobile Applications

Mobile device manufacturers set their own rules for application distribution. Apple has the most strict rules for the iOS developers.

Apple runs the https://developer.apple.com/programs/start/ios/[iOS Developer Program], and if you're an individual who wants to distribute iOS application on the App Store, it'll cost you $99 per year. Higher education institutions who teach iOS development are enrolled into this program for free. iOS Developer Enterprise program costs $299 a year.

Besides being able to deploy the application in the App Store, developers are allow their beta-customer to test the application even before they were accepted in the store. Individual developers can share their application among up to 100 iOS devices identified by UUID (click on the serial number of your device in iTunes to see it). It's so-called Ad Hoc distribution.   
For example, after the PhoneGap Build service has built the .ipa file for the iOS, you can make it available for installation right on the beta-tester's device using such services as http://www.diawi.com/[diawi] or https://testflightapp.com/[TestFlight]. Upload the .ipa file and its provisioning profile to one of these services and you'll get the link (a URL) to be given to your testers -the UUID of their devices must be registered with your developer's profile. To do this, login to your account at developer.apple.com, select the section "Certificates, Identifiers & Profiles", then go to Devices and add the UUID of the iOS device to the existing list of registered devices. 

The owners of the enterprise license can distribute their applications right from their own Web sites.

Figure <<FIG14-5>> shows the snapshot from the iPhone after the tester clicked on such a link from diawi. Pressing the button Install Application completes the install of the application on your iOS device. 

[[FIG14-5]]
.Ad hoc application install from diawi
image::images/fig_14_05.png[] 


Android developers are not restricted in distributing of their application - upload the APK package with your application to your corporate Web site and send the URL to anyone who's interested. For example, the authors of this book are creating a software for insurance industry, where they offer to download both iOS and Android versions of the application right from their corporate Web site as shown at Figure <<FIG14-6>>. 

[[FIG14-6]]
.Distributing mobile applications at surancebay.com 
image::images/fig_14_06.png[]


=== Save Sick Child with PhoneGap

To demonstrate how the turn a Web application into a hybrid one, we'll take the code of the jQuery Mobile version of the Save Sick Child application  from Chapter 12), add to it an ability to work with the photo camera using PhoneGap API, and create two builds ready to be deployed on iOS and Android platforms. in this exercise we'll use PhoneGap 3.0, which is the latest version at the time of this writing. 

But before even adding camera support, let's go through the process of building and deploying the jQuery Mobile version of this application in its existing form without changing even one line of code. 

NOTE: Usually, PhoneGap is mentioned in the context of building hybrid applications, that need to access some native API. But PhoneGap can be used for packaging any HTML5 application as a native one regardless of if it uses native API or not. 

We'll start with packaging this application for iOS and then we'll ask PhoneGap to use the same code and build the application for multiple mobile platforms. We'll continue using XCode IDE under MAC OS to be able to prepare the code for iOS. Here's the step by step plan: 

1. Generate a new PhoneGap project using the Cordova CLI as we did with Hello World. This time we won't add any specific mobile SDKs to the project. 

2. Copy the existing HTML, CSS, JavaScript and other resources from jQuery Mobile Save Sick Child application into the directory _www_ of the newly generated Cordova iOS project.

3. Compress the entire content of the _www_ directory into a ZIP file, upload it to PhoneGap Web site and generate the packages for several platforms.

5. Test the Save Sick Child application on the Android, iOs and other devices you can find.


While simulators and emulators can be very handy, nothing is better than testing on the real devices. There are several models of iPhones that vary by the CPU power and screen resolution. Ensuring that the application performs well on Android devices is a lot more challlenging - this market is really fragmented in both hardware and OS. Android emulators are not as good as the iOS ones. On the other hand, iOS emulator won't allow you to test integration with camera in our Save Sick Child applications. Such features of the real devices like accelerometor or gyroscope simply can't be test with emulators. 

TIP: If you've architected your hybrid application in a modularized fashion as described in Chapter 7, you'll get an additional benefit. If the code of one of the loadable modules changes, but the main application shell remains the same, there is no need to resubmit the new version of the application to the App Store or a market, which can be a serious time saver on Apple devices - you eliminate the approval process on each new version of the application. 

=== Creating Custom Plugins

// http://devgirl.org/2013/07/17/tutorial-how-to-write-a-phonegap-plugin-for-android/


=== Summary

Hybrid applications allow you to take your HTML5-based Web application, connect it to the native API of the mobile device and package it as a native application. The selling point of using hybrids is that you can reuse the existing HTML5/JavaScript expertise. In the enterprise setup maintaining bugs in a one-language bug database is a lot more easier than if you have multiple versions of the application written in different languages. Maintaining a single set of images, videos, and CSS files makes is yet another advantage that lowers both time to market and cost of ownership of the application.   

Thorough testing of hybrid application is a must. With the BYOD policies even the enterprise applications nust be tested on a variety devices. Development manager and application owners have to agree on the list of mobile devices where your application will be deployed first. This has to be done in writing in the early stages of the project and be as detailed as possible. The statements like "The initial version of the application will run on iOS devices" is not good enough, because the difference between iPhone 3GS and iPhone 5 is huge. The former has 256MB of RAM, 600 Mhz CPU, and 480x320 pixels screen, while the latter champions 1GB of RAM, 3-core A6 CPU at 1.3Ghz, and 1135x640 pixels display.  

Hybrid applications not only give the developers and users access to native capabilities of the mobile devices, but allow distribute your HTML5 application through multiple App Stores or Market Places offered by the device manufacturers. 

Enterprise managers are always concerned with availability of the paid technical support. A substantial part of this chapter was about using PhoneGap, and Adobe offers http://phonegap.com/support/#developer[various support packages] for purchase.  

Make no mistakes though - if you want to create the fastest possible application that looks exactly like other applications created for the selected mobile platform, develop it in the native language prescribed by the device manufacturer. Faster applications take less CPU power, which translates to a longer battery life on the device. Will you be able to afford having experts in each mobile OS is a different and non-technical question. If you don't have such a luxury, going hybrid is a good compromise.  


== Epilogue


Even though this book is about HTML5, the authors would rather work with compiled languages that produce applications to run in virtual machines. Such software platforms are more productive for development and more predictable for deployment. While writing this book we were often arguing about pros and cons of switching to HTML5, and so far we are concerned that the HTML/JavaScript/CSS platform is not ready for developing of the enterprise applications just yet. We live in the era when amateurs feel comfortable creating Web sites and that JavaScript provides flexibility and customization the Access and Excel provided in the old good PC times. 

Till this day Microsoft Excel is the most popular application among business users in the enterprises. They start the application locally, it has a local storage that enables work in the occasionally-connected scenarios. Both the data and the code are physically located close to the user's heart. Microsoft Excel allows the users to have her own little pieces of data and amateurish-but-working-code (a.k.a. formulas) very close and personal. Right on the desktop. No need to ask these IT prima donnas for favors. No dependencies on the connectivity or some mysterious servers being slow or down. The most advanced business users even learn how to operate MS Access database to further lessen the dependency from IT.  

But there is only so much you can do with primitive tools. Visual Basic was "JavaScript" of the nineties - it had similar problems, but nevertheless had huge followings. Now the same people are doing JavaScript. If we don't break this cycle by adopting a common to all browsers VM, we are doomed for going through the generation after generation of underpowered crap. 

Recently, one of our clients from Wall Street sent us a list of issues to be fixed in an Web application that we were developing using Adobe Flex framework (Flash Player was the VM, where this application ran). One of the requested fixes was "remove a random blink while a widget moves in the window and snaps to another one". We've fixed it. You may argue that Flash Player as any browser's plugins are going away.  But the bar set by Flash based enterprise applications is set pretty high. We hope that future enterprise Web applications developed with HTML6 will raise the expectations in the user experience area. The time will come when HTML widgets won't blink in any of the major browsers.

We wrote this book to help people with understanding of what HTML5 applications are about. But make no mistakes - the world of HTML5 is not a peachy place in the future preached by educated and compassionate scientists, but rather a nasty past that is catching up bringing the mob with it.

It's past and it's the future. The chances are slim that any particular vendor will win all or even 80% of the market of the mobile devices. In competitive business, being able to make an application available ONLY to 80% of the market is not good enough, hence the chances that any particular native platform will dominate in the Web developers are slim. HTML5 and related technologies will serve as a common denominator for mobile developers.

The authors of this book have more than 100 years of combined experience in development of enterprise applications. Over these years we've learned that the saying "Today's on Wall Street, tomorrow on Main street" works. IT departments of financial companies are very pragmatic in selecting tools for development of their software. Especially, we're watching the platforms used for development of financial trading applications - they must be fast, reliable, and any delays in processing or clumsy UI may lead to substantial money losses. Besides, the development cost dramatically increases if an IT organization sets a goal to offer their trading application to the entire mobile market, which is a moving target today and will remain the same in the foreseeable future.

Check out one of the trading applications named https://www.trademonster.com/trading/mobile-trading.jsp[tradeMonster]. It has been developed using HTML5 and uses the same code base for all mobile devices. The desktop version was built using Adobe Flex framework that uses Flash Player as a VM. Yes, they have created native wrappers to offer this application in Apple or Google's application stores, but it's still an HTML5 application nevertheless. You can create a paper trading account (no money is involved in trading) and test their application. If you like it, consider using HTML5.  

Enterprise IT managers need a cross platform development and deployment platform, which HTML5 is promising to be. Take with a grain of salt all the promises of being 100% cross-platform made by any HTML5 framework vendor. "With our HTML5 framework you won't need to worry about differences in Web browsers". Yeah, right! HTML5 is not a magic bullet, and don't expect it to be. But HTML5 is for real and may become the most practical development platform for your organization today.

Unfortunately, developing an application in JavaScript is not overly productive. Some people use CoffeScript or TypeScript to be converted for JavaScript for deployment. We are closely watching the progress with Google's new programming language called Dart. It's a compiled language with an elegant and terse syntax, which is easy to understand to anyone who knows Java or C#. Although compiled version of the Dart code requires Dartium VM, which is currently available only in the Chromium browser, Google created dart2js compiler that turns your application code into JavaScript in seconds so it can run in all Web browsers today. Google also offers Dart IDE with debugger and autocomplete features. You can debug the Dart code in Dart Editor while running generated JavaScript in the browser. 

Dart's VM can communicate with JavaScript's VM, so if you have a portion of your application written in JavaScript, it can peacefully coexist with the Dart code. You can literally have two buttons on the Web page: one written in JavaScript and the other in Dart. 

W3C published a document called https://dvcs.w3.org/hg/webcomponents/raw-file/tip/explainer/index.html["Introduction to Web Components"], which among other things defines recommendations on how to create custom HTML components. The existing implementation of Web UI package includes a number of UI components and allows defining new custom HTML elements in a declarative way. Here's an example we borrowed from the http://www.dartlang.org/articles/web-ui/[Dart Web site]:

[source, html] 
====
  <element name="x-click-counter" constructor="CounterComponent" extends="div">
    <template>
      <button on-click="increment()">Click me</button>
      <span>(click count: {{count}})</span>
    </template>
    <script type="application/dart">
      import 'package:web_ui/web_ui.dart';

      class CounterComponent extends WebComponent {
        int count = 0;
        void increment(e) { count++; }
      }
    </script>
  </element>
==== 

This is code extends a Web UI element `div` and includes a template, which uses binding. The value of the variable `count` is bound to `<span>` and as soon as a counter increases, the Web page immediately reflects its new value without the need to write any other code. The Web UI package will be replaced soon with the http://www.polymer-project.org/[Polymer Stack] built on top of Web components. In 2014, the popularity of Dart should increase if Google will remain committed to this project. In this case, we'll send a new proposal to O'Reilly Media for a book titled "Enterprise Web Development with Dart".