:toc:
:toclevels: 4
:icons: font
:imagesdir: ./images

== Large-Scale JavaScript Projects

Reducing the  startup latency and implementing lazy loading of certain parts of the application are the main reasons for modularization. A good illustration of why you may want to consider cutting the code into pieces is a well designed Web application of the http://www.mbusa.com/[Mercedes Benz USA]. This Web application serves people who live in America and either own or consider purchasing cars from this European car manufacturer.

One of the options to purchase a vehicle is called European Delivery. An American resident can combine car purchase with a vacation. She would fly to Europe to the Mercedes Benz factory, pick up the car there and then she would be vacationing for two weeks driving her new vehicle in Europe. After the vacation is over, this car would be shipped to her home town in the USA.  This really nice program  would have added several thousand dollars to the price of the car.

From the application design code of view, we don't need to include the code that supports the European Delivery to each and every user's who decided to visit mbusa.com. _If and only if_ the user visits the menu Owners and clicks on the European Delivery link, then the required code and resources have to be pushed to the user's computer or mobile device. The snapshot in <<FIG7-1>> was taken after clicking on this link with Chrome Developer tools panel open.

[[FIG7-1]]
.MB USA: Europian Delivery 
image::fig_07_01.png[image]

As you see, _1.9Mb_ worth of code and other resources have been downloaded as a result of this click. Should the application architects of the MB USA decided to bring this code to the user's device on the initial load of http://mbusa.com, the wait time would increase by another second or more. This  is unnecessary because only a tiny number of American drivers would be interested in exploring the European Delivery option. This example illustrates the use case where modularization and lazy loading is needed.

Our Save Sick Child application is not as big as the Mercedes Benz site. But we'll use it to give you an example of how to build modularized Web applications that won't bring the large and monolithic application to the client's machine, but will load the code on as needed basis. We'll also give an example of how to organize the data exchange between different programming modules in a loosely coupled fashion.

Users consider a Web application fast for one of two reasons: either it's actually fast or it gives an impression of being fast. Ideally, you should do your best to create a Web application that's very responsive. 

TIP: No matter how slow your Web application is, it should never feel like it's being frozen.

This chapter is about modularization techniques that will allow quick rendering of the first page of your Web application by the user's browser while loading the rest of the application in the background or on demand. We will continue refactoring the Save Sick Child application to illustrate using modules.

=== Modularization basics

Modules are code fragments that implement certain   functionality written using a specific techniques. There is no out-of-the box modularization scheme in JavaScript language. The upcoming ECMAScript 6 specification tends to resolve this by introducing the _module concept_ in the JavaScript language itself. This is the future. 

You may ask, "Aren't .js files modules already?" Of course, you can include and load each JavaScript file using the `<script>` tag. But this approach is error prone and slow. Developers have to manually manage dependencies and file loading order. Moreover, each `<script>` tag results in the  additional HTTP call to the server.

As the application gets larger the number of script files grows accordingly, which is illustrated in the following 
<<LISTING_SCRIPT_TAG, code sample>>.

[[LISTING_SCRIPT_TAG]]
.Multiple `<script>` tags complicate controlling  application dependencies
[source,html]
----
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8">
    
    <title>Save Sick Child | Home Page</title>
    <link rel="stylesheet" href="assets/css/styles.css">

    <script src="components/jquery.js></script>     <!--1-->

    <script type="text/javascript" src="app/modules/utils/load-html-content.js"></script>
    <script type="text/javascript" src="app/modules/utils/show-hide-div.js"></script>
    <script type="text/javascript" src="app/modules/svg-pie-chart.js"></script>
    <script type="text/javascript" src="app/modules/donation.js"></script>
    <script type="text/javascript" src="app/modules/login.js"></script>
    <script type="text/javascript" src="app/modules/utils/new-content-loader.js"></script>
    <script type="text/javascript" src="app/modules/generic-module.js"></script>
    <script type="text/javascript" src="app/modules/module1.js"></script> <!--2-->
    <script type="text/javascript" src="app/modules/module2.js"></script>
    <script type="text/javascript" src="app/config.js"></script>
    <script type="text/javascript" src="app/main.js"></script> <!--3-->

</head>
<body>
<!-- page body -->

</body>
</html>
----
<1> Loading the jQuery first because all other modules depend on it.

<2> Other application components may also have internal dependencies on other scripts. Those scripts need to be loaded before the respective components. Having the proper order of these script tags is very important.

<3> The script for the main Web page should be loaded after all dependencies have finished loading.

We need other than adding `<script>` tags approach to modularizing applications. Let's start with using the Module pattern to leverage so called Immediately-Invoked Function Expressions (IIFE) as the first step to modularization. Next, we'll introduce and compare two popular JavaScript solutions and modularization patterns - CommonJS and Asynchronous Module Definition (AMD), which are alternative approaches to modularization. Both CommonJS and AMD are specifications defining sets of APIs. 

You'll learn pros and cons of both formats later in the chapter, but the AMD module format plays nicely with the asynchronous nature of Web. In this chapter you'll see the use of the AMD module format and http://requirejs.org/[RequireJS] framework to implement the modularized version of the Save Sick Child application.

Also, you'll see how to use the RequireJS APIs to implement on-demand loading of the application components (e.g. What We Do, Ways To Give et al.)

The upcoming ECMAScript 6 specification suggests how to handle modules, and how to start using ES6 module syntax today with the help of third-party tools like http://corner.squareup.com/2013/02/es6-module-transpiler.html[transpiler]. The ES6 module syntax can be compiled down to existing module solutions like CommonJS or AMD. You can find more details about CommonJS, AMD and the ES6 module format in the corresponding sections of this chapter.

After application modules are asynchronously loaded, they need to communicate to each other. You can explicitly specify the components dependencies, which is fine as long as you have a handful of  components. A more generic approach is to handle inter-module communications in a loosely coupled fashion using the _Mediator_ pattern, CommonJS or AMD formats. By _loosely coupled_ we mean that components are not aware of each other's existence.

The next section reviews various approaches and patterns of modular JavaScript applications.

=== Roads To Modularization

Although JavaScript has no build-in language support of modules, the developers' community has managed to find a way for modularization using existing syntax constructs, libraries and conventions to emulate modules-like behavior. The _Module pattern_ doesn't require any additional frameworks and works in any JavaScript environment. The _CommonJS_ module format is widely adopted for the server-side JavaSctipt, while the _AMD_ format is popular in the applications running in Web browsers. 

==== The Module Pattern

In software engineering, the Module pattern was originally defined as a way to implement encapsulation of reusable code. In JavaScript, the Module pattern is used to emulate the concept of classes. We're able to include both public and private methods as well as variables inside the single object, thus hiding the encapsulated code from other global scope objects. Such encapsulation lowers the likelihood of conflicting function names defined in different scripts that could be used in the same application's scope.

Ultimately, it's just some code in an IIFE that creates a module object in the internal scope of a function and exposes this module to the global scope using the JavaScript language syntax. Consider the following three code samples illustrating how the Module pattern could be implemented using IIFEs.

.Returning the value from a module 
[source,javascript]
----
include::include/ch7_iife_loginModule.js[]
----
<1> Assigning the module object that was created in the closure to the variable `loginModule`.
<2> Because of the JavaScript's function scoping, other parts of the code can't access the code inside the closure. With this approach you can implement encapsulation and private members.

.Injecting the module into the global object 
[source,javascript]
----
include::include/ch7_iife_global_loginModule.js[]
----
<1> Instead of exporting the module to a variable as in the previous example, we're passing the global object as a parameter inside the closure.
<2> Attaching the newly created object to the global object. After that the `loginModule` object can be accessed from the external application code as `window.loginModule` or just `loginModule`.

.Introducing namespaces in the global object
[source,javascript]
----
include::include/ch7_iife_namespace_loginModule.js[]
----
<1> Here we have modification of the approach described in previous snippet. To avoid name conflicts, create a namespace for our application called `ssc`. Note that we check for this object existence in the next line.
<2> Now we can logically structure application code using namespaces. The global `ssc` object will contain only the code related to the Save Sick Child application.

The Module patterns works well for implementing encapsulation in a rather small applications. It's easy to implement and is frameworks agnostic. However this approach doesn't scale well because when working with an application with the large number of modules you may find yourself adding lots of boilerplate code checking objects' existence in the global scope for each new module. Also, you need to be careful with managing namespaces: since you are the one who put an object into the global scope, you need to think  how to avoid accidental names conflicts.

The Module pattern has a serious drawback - you  still need to deal with manual dependency management and manually arrange `<script>` tags in the HTML document. 

==== CommonJS

http://www.commonjs.org/[CommonJS] is an effort to standardize JavaScript APIs. People who work on CommonJS APIs have attempted to develop standards for both modules and packages. The CommonJS module proposal specifies a simple API for declaring modules, but mainly on the server-side. The CommonJS module format was optimized for non-browser environments since the early days of the server-side JavaScript.

.Node.js, V8, and NPM
****
Node.js (or simply Node) is a server-side JavaScript framework. Node uses V8, the JavaScript engine by Google used in Chrome/Chromium. The V8 engine provides JavaScript API for accessing the file system, sockets and  running processes. The Grunt tool is built on top of Node JavaScript APIs. You can find more information about Node.js at  http://nodejs.org/about/[their website].

Node Package Manager (NPM) is a utility as well as https://npmjs.org/[community repository] for open source JavaScript projects. NPM provides unified API and metadata model for managing dependencies in JavaScript projects. A `package.json` file is the project's dependencies descriptor. NPM installs project dependencies using information from `package.json`.

Node and NPM are cross-platform software and binaries available for Windows, Linux and Mac OS X operating systems. 

To use code samples from this chapter you need to download and install Node from http://nodejs.org/download/[their web site]. Then follow http://gruntjs.com/getting-started[ the instructions from Grunt's  website] to install it on your machine.
****

On the Web browser side, you always need to consider potentially slow HTTP communications, which is not the case on the server. One of the solutions suitable for browsers is to concatenate all scripts into a handful of bundles to decrease the number of HTTP calls, which was not a concern for the server-side JavaScript engines because file access is nearly instantaneous. On the server side separation of the code allowed to dedicate each file to exactly one module for ease development, testing and maintainability.

In brief, the CommonJS specification requires the environment to have  http://wiki.commonjs.org/wiki/Modules/1.1#Module_Context[three free variables]: `require`, `exports`, and `module`. The syntax to define the module is called _authoring format_. To make the module loadable by a Web browser it has to be transformed into _transport format_. 

[source,javascript]
----
include::include/ch7_commonjs.js[]
----
<1> If a module requires other modules, declare references to those modules inside the current module's scope by using the `require` function. You need to call `require(id)` for each module it  depends on.  The module id has slashes defining the file path or a URL to indicate namespaces for external modules. Modules are grouped into a packages.

<2> The `exports` object exposes the public API of a module. All objects, functions, constructors that your module exposes must be declared as properties of the `exports` object. The rest of the module's code won't be exposed.

<3> The `module` variable provides the metadata about the module. It holds such properties as `id` and a unique `uri` of each module. The `module.export` exposes `exports` object as its property. Because objects in JavaScript are passed as references, the `exports` and `module.exports` point at the same object.

WARNING: The snippet above may give you an impression that the module's code is executed in the global scope, but it's not. Each module is executed in its own scope which helps to isolate them. This works automatically when you write modules for NodeJS environment running on the server (see Chapter 8). But to use CommonJS module format in the Web browser you need to use an extra tool to generate transport format from _authoring format_. http://browserify.org/[Browserify] takes all your scripts and concatenates them it to one large file.  Besides the module's code the generated transport bundle will contain the boilerplate code that provides CommonJS modules runtime support in the browser environment. This build step complicates the development workflow. Usually developers perform the _code/save/refresh browser_ routine, but it doesn't work in this case and requires an extra steps as you need to install the additional build tool and write  build scripts. 


[underline]#CommonJS pros:#

* It's a simple API for writing and using modules.
* Such a pattern of organizing  modules is widespread in the server-side JavaScript, e.g. NodeJS.

[underline]#CommonJS cons:#

* Web browsers don't automatically create the scoped variables `require`, `exports`, `module` hence the additional build step is required.
* The `require` method is synchronous, but there is no exact indication if dependent module's values are fully loaded because of the asynchronous nature of Web browsers. There is no event to notify the application that 100% of the required resources is loaded. 
* CommonJS API is suitable for loading +.js+ files, but it can't load other assets like CSS and HTML.

NOTE: If you want to write modules in the format that can be used in both browser and server's  environments read our suggestions in the  <<umd>> section on this chapter.

Further reading:

* http://wiki.commonjs.org/wiki/Modules/1.1[CommonJS Modules 1.1 specification]
* http://nodejs.org/docs/latest/api/modules.html#modules_modules[Node.js Modules Reference]


[[amd_section]]
==== Asynchronous Module Definition

AMD began as a draft specification for module format in CommonJS, but since the full agreement about its content was not reached, the further work on module's format moved to the https://github.com/amdjs[amdjs Github page].

The AMD module format itself is a proposal for defining modules where both the module and dependencies can be asynchronously loaded. 
The AMD API is based on https://github.com/amdjs/amdjs-api/wiki/AMD[this specification]. The AMD API have the following main functions:

[[DEFINE_DESC]]
* `define` for facilitating module definition. This function takes tree arguments:
** The optional module id
** An optional array of modules' IDs of dependencies
** A callback function (a.k.a _factory function_), which will be invoked when dependencies are loaded. 
+

[[LISTING_define_func]]
.The signature of a `define` function
[source,javascript]
----
define(
    module_id,          // <1>
    [dependencies],     // <2>
    function {}         // <3>
);
----
<1> This string literal defines +module_id+ that will be used by the AMD loader for loading this module.
<2> An optional array of dependencies' ids.
<3> The function for instantiating the module or object. The factory function will only be executed once
+

For example, the Save Sick Child application has a menu Way To Give, which in turn depends on other module called `otherContent`. If the user clicks on this menu, we can load the module that can be defined in the +wayToGive.js+ as follows:
+

[[LISTING_define_modeule]]
.The definition of the wayToGive module
[source,javascript]
----
include::include/ch7_define_wayToGive.js[]
----
<1> This code doesn't have the optional +module_id+. The loader will use the file name without the `.js` extension as +module_id+. Our module has one dependency on the module called +otherContent+. The dependent module instance will be passed in the factory method as variable +otherContent+. 
<2> We can start using the dependency object immediately. AMD loader have taken care of loading and instantiation of this dependency.
<3> The module returns constructor function to be used for creation of new objects.

[[REQUIRE_DESC]]
* The `require` function takes two arguments
** An array of module IDs to load. Module ID is a string literal.
** A callback to be executed once those modules are available. The modules loaded by IDs are passed into the callback in order. <<LISTING_Require_func,Here is example>> of the `require` function usage.
+

[[LISTING_require_func]]
.The example of `require` function usage
[source,javascript]
----
require(["main"], function() {
    console.log("module main is loaded");
}); 
----

[underline]#AMD pros:#

* It's a very simple API that has only two functions - `require` and `define`. 

* A wide variety of loaders is available. You'll find more coverage on loaders in the <<REQUIREJS, RequireJS section>>.

* A CommonJS module authoring format is supported by the majority of loaders. You'll see an example of modules later in the <<require_cjs>> section. 


* Plugins offer an immense amount of flexibility.

* AMD is easy to debug.
+

Consider the following error messages that JavaScript interpreter may throw:
+

_There was an error in +/modules/loginModule.js+ on line_ *42*
+

*vs*
+

_There was an error in +/built-app.js+ on line_ *1984*
+

In modularized applications you can easier localize errors.

* Performance: module are loaded only when required hence the initial portion of the application's code become smaller.

[underline]#AMD Cons:#

* The dependency array can get rather large for complex modules.
+

[source,javascript]
----
include::include/ch7_define_large_array_of_deps.js[]
----
<1> In the real-world enterprise applications the array of dependency modules might be pretty large.

* Human errors can result in mismatch between dependency array and callback arguments.
+

[source,javascript]
----
include::include/ch7_define_module_ids_order.js[]
----
<1>  The mismatch of module IDs and factory function arguments will cause module usage problems.


[[umd]]
==== Universal Module Definition

Universal Module Definition (UMD) is a series of patterns and code snippets that provide compatibility boilerplate to make modules environment-independent. Those patterns can be used to support multiple module formats. Here is an example of the module definition in UMD notation. In the following example, the module can be used with the AMD loader and as one of the variations of the Module Pattern.


[source,javascript]
----
include::include/ch7_umd_amd_globals.js[]
----
<1> If the AMD loader is available proceed with defining the module according to AMD specification.

<2> If the AMD loader isn't present, use the factory method to instantiate the object and attach it to the `window` object.

<3> Passing the top-level context and providing a implementation of a factory function.

It's worth mentioning that UMD is not a specification or a standard. You need to pay attention to UMD patterns in case when your modules will run in more than one type of environment (e.g. a Web browser and on the server side engine running NodeJS). In most cases, it makes a lot of sense to use a single module format.

You can find more information about UMD and commented code snippets for different situations in https://github.com/umdjs/umd[the UMD project repository].

==== ECMAScript 6 Modules

The ECMAScript 6 (ES6) specification is an evolving draft outlining changes and features for the next version of the JavaScript language. This specification is not finalized yet and the browsers' support for anything defined in ES6 will be experimental at best and cannot be relied upon for Web applications that must be deployed in production mode in multiple browsers. 

One of the most important features of ES6 specification is the _module syntax_. Here is an example of some login module definition:

.Login module definition
[source,javascript]
----
export function login(userNameValue, userPasswordValue) { // <1>
    console.log("login implementation omitted");
};
----
<1> The keyword `export` specifies the function or object (a separate file) to be exposed as a module, which can be used from any other JavaScript code as follows:

.Main application module
[source,javascript]
----
import login from 'login'
var result = login("admin", "password");
----

.ES6 Module Transpiler
****
Although ES6 standard is not implemented yet by most of browsers you can use the third party tools to get a taste of upcoming enhancements in JavaScript language. http://corner.squareup.com/2013/02/es6-module-transpiler.html[ES6 Module Transpiler] library developed by the http://squareup.com/[Square] Engineers helps using the module authoring syntax from ES6 and compile it down to the transport formats that you learned earlier in this chapter.

Consider the following module circle.js: 

.A `circle.js` module
[source, javascript]
----
export function area(radius) { 
  return Math.PI * radius * radius;
}

export function circumference(radius) { 
  return 2 * Math.PI * radius;
}
----
This module exports two functions: `area()` and `circumference()`.

.The main application's script `main.js` can use these functions
[source, javascript]
----
import { area, circumference } from 'circle';     // <1>

console.log("Area of the circle: " + area(2) + " meter squared");   // <2>
console.log("Circumference of the circle: " + circumference(5) + " meters");
----
<1> The `import` keyword specifies the objects we want to use from the module.
<2> A sample use of the imported functions

The ES6 Module Transpiler's command `compile-module` can compile the module to be compliant with CommonJS, AMD, or the code that implements the Module pattern. With the `type` command line option you can specify that output format will be: _amd_, _cjs_ and _globals_.

----
compile-modules circle.js --type cjs --to ../js/  
compile-modules main.js --type cjs --to ../js/
----

* *CommonJS* format
+

.circle.js
[source,javascript]
----
"use strict";

function area(radius) {
    return Math.PI * radius * radius;
}

function circumference(radius) {
    return 2 * Math.PI * radius;
}
exports.area = area;
exports.circumference = circumference;
----
+

.main.js
[source,javascript]
----
"use strict";
var __dependency1__ = require("circle");
var area = __dependency1__.area;
var circumference = __dependency1__.circumference;

console.log("Area of the circle: " + area(2) + " meter squared");
console.log("Circumference of the circle: " + circumference(5) + " meters");
----

Should we compiled the modules into the AMD format using the option _amd_, we would have received a different output in the AMD format.

* *AMD* format
+

.circle.js
[source,javascript]
----
define("circle", ["exports"],
    function(__exports__) {
        "use strict";

        function area(radius) {
            return Math.PI * radius * radius;
        }

        function circumference(radius) {
            return 2 * Math.PI * radius;
        }
        __exports__.area = area;
        __exports__.circumference = circumference;
    });
----
+

.main.js
[source,javascript]
----
define("main", ["circle"],
    function(__dependency1__) {
        "use strict";
        var area = __dependency1__.area;
        var circumference = __dependency1__.circumference;

        console.log("Area of the circle: " + area(2) + " meter squared");
        console.log("Circumference of the circle: " + circumference(5) + " meters");

    });
----

Using the _globals_ option in the _compile-modules_ command line produces the code that can be used as described in the Module Patter section earlier in the chapter. 

* Browser globals
+

.circle.js
[source,javascript]
----
(function(exports) {
    "use strict";

    function area(radius) {
        return Math.PI * radius * radius;
    }

    function circumference(radius) {
        return 2 * Math.PI * radius;
    }
    exports.circle.area = area;
    exports.circle.circumference = circumference;
})(window);
----
+

.main.js
[source,javascript]
----
(function(circle) {
    "use strict";
    var area = circle.area;
    var circumference = circle.circumference;

    console.log("Area of the circle: " + area(2) + " meter squared");
    console.log("Circumference of the circle: " + circumference(5) + " meters");

})(window.circle);

----

To learn the up-to-date information on the ES6 browsers' support visit http://kangax.github.io/es5-compat-table/es6/[ECMAScript 6 compatibility table].
****

NOTE: http://www.typescriptlang.org/[TypeScript] is an open-source language from Microsoft that compiles to JavaScript and brings object-oriented concepts like classes and modules to JavaScript. It has a module syntax, which is very similar to what ES6 standard proposes. The TypeScript compiler can produce CommonJS and AMD module formats. You can learn more about TypeScript from http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf[language specification]. You can find Save Sick Child application written in TypeScript in Appendix B.

[[REQUIREJS]]
=== Dicing the Save Sick Child Application Into Modules

Now that you know the basics of AMD and different modularization patterns, let's see how you can dice our Save Sick Child application into smaller pieces. In this section we'll apply the AMD-complaint module loader from the framework http://requirejs.org/[RequireJS].

TIP: http://github.com/cujojs/curl[curl.js] offers  another AMD-compliant asynchronous resource loader. Both curl.js and RequireJS have similar functionality, and to learn how they differ follow https://groups.google.com/forum/#!topic/requirejs/niUyLZrivgs[this thread on RequireJS group]. 

Let's start with a brief explanation of the directory structure of the modularized Save Sick Child application.

[[ssc_structure]]
.A directory structure of Save Sick Child
image::fig_07_05.png[align="center"]

1. All application's JavaScript files reside in the _app/modules_ directory.
+

Inside the _modules_ directory you can have as many nested folders as you want, e.g. _utils_ folder.

2. The application assets remain the same as in previous chapters.
3. We keep all Bower-managed dependencies (see the sidebar <<what_is_bower>> ) in the _components_ directory such as  RequireJS, jQuery etc. 
4. The _dist_  directory serves as the location for the optimized version of our application. We will cover optimization with `r.js` later in the <<using_reuiqrejs_optimizer>> section.
5. The QUnit/Jasmine tests will live in the _test_ directory. Testing will be covered in Chapter 8. 

We are not going to dice the Save Sick Child application into multiple modules, but will just show you how to start this process. <<ssc_modules_graph>> illustrates the modules' dependencies. For example, the `main` module depends on `login`, `svg-pie-chart`, `campaigns-map`, `donation`, and `generic`. There is also a group of modules that will be loaded on demand: `whereWeWork`, `whatWeDo`, `wayToGive`, `whoWeAre`.

[[ssc_modules_graph]]
.The modules graph of Save Sick Child
image::fig_07_08.png[align="center"]

To dice the application into modules you'll need the the modularization framework RequireJS, which can either be downloaded from its github repository or you can install it using a package manager <<what_is_bower,Bower>>.

[[what_is_bower]]
.What is *Bower*?
****
https://github.com/bower/bower[Bower] is a package manager for Web projects. Twitter has  donated it to the open-source community. Bower is a utility and a community driven repository of libraries that help in downloading the third-party software required for the application code that will run in a Web  browser. The Bower's purpose is very similar to NPM, but the latter is more suitable for the server-side projects.

Bower can take care of transitive (dependency of a dependency) dependencies and download all required library components. Each Bower's package has a bower.json file, which contains the package metadata for managing the package's transitive dependencies. Also, bower.json can contain information about the package repository, readme file, license et al. You can find bower.json in the root directory of the package. For example, _components/requirejs/bower.json_ is a path for the RequireJS metadata file. Bower can installed via NPM. The following line shows how to install Bower globally in your system.

[source,bash]
----
npm install -g bower    
----

You can start using Bower now. For example, here is a Bower's command to install RequireJS.

[source,bash]
----
bower install requirejs --save 
----
Bower installs RequireJS into _components/requirejs_ directory and saves information about dependencies in bower.json configuration file.

Bower simplifies the delivery of dependencies into target platform, which means that you don't need to store dependencies of your application in the source control system. Just keep you application code there and let Bower to bring all other dependencies described in its configuration file. 

TIP: There are pros and cons for storing dependencies in the source control repositories. Read the http://addyosmani.com/blog/checking-in-front-end-dependencies/[article by Addi Osmani] that covers this subject in more detail.

Your application will have its own file bower.json with the list of the dependencies. At this point, Bower can install all required application dependencies with one command - `bower install`, which will deliver all your dependency files into the +components+ directory. Here is the content of the file bower.json for our Save Sick Child application. 

[source,javascript]
----
{
  "name": "ch7_dynamic_modules",
  "description": "Chapter 7: Save Sick Child, Dynamic Modules app",
  "dependencies": {
    "requirejs": "~2.1.5",
    "jquery": ">= 1.8.0",
    "qunit": "~1.11.0",
    "modernizr": "~2.6.2",
    "requirejs-google-maps": "latest"
  }
}
----

Application dependencies are specified in corresponding "dependencies section. The _>=_ sign specifies that the corresponding software has to be not older than the specified version.

[[application_components]]
.Directory structure of application's components
image::fig_07_04.png[align="center"]

Also, there is a http://sindresorhus.com/bower-components/[Bower search tool] to find the desired component in its repository.

****

Once RequireJS downloaded and placed into the project directory, add it to the index.html file as demonstrated in <<add_requirejs>> snippet.

[[add_requirejs]]
.Adding RequireJS to the web page
[source,html]
----
<!DOCTYPE html>
<head>
    <!-- content omitted -->
</head>
<body>
<!-- page body -->

<script src="components/requirejs/require.js" 
        data-main="app/config"></script> <!--1-->

</body>
</html>
----
[[data_main_attrib]]
<1> Once the RequireJS library is loaded it will look for the `data-main` attribute and attempt to load the `app/config.js` script asynchronously. The `app/config.js` will become the entry point of our application.


[[inside_config]]
==== Inside config.js

RequiredJS uses a configuration object that includes modules and dependencies that have to be managed by the framework.

[source,javascript]
----
include::include/ch7_require_config.js[]
----
<1> The http://requirejs.org/docs/api.html#config[RequireJS documentation] has a comprehensive overview of all configuration options. We've included some of them here. 

<2> The `paths` configuration option defines the mapping for module names and their paths. The `paths` is used for module names and shouldn't contain file extensions.

<3> After configuring the modules' paths we're loading the 'main' module. The navigation of our application flow starts there.


==== Writing AMD Modules

Let's take a closer look at the module's internals that make it consumable by the RequireJS module loader.


[source,javascript]
----
include::include/ch7_module_contentLoader.js[]
----
<1> As we discussed in the <<amd_section>> section, the code that you want to expose as a module should be wrapped in the `define()` function call. The first parameter is an array of dependencies. The location of dependencies files is defined <<inside_config, inside the config file>>. The dependency object doesn't have the same name as the dependency string id. The order of arguments in the factory function should be the same as the order in the dependencies array.

<2> In this module we export only in the constructor function that returns the object that uses the _render_ function to draw the visual component on the screen.  

<3> The `contentLoader` object loaded from _app/modules/util/new-content-loader.js_ (see the `paths` property <<inside_config, in RequireJS config object>>), is instantiated by RequireJS and is ready to use. 

RequreJS also supports the CommonJS module format with a slightly different signature of the `define()` function. This helps to bridge the gap between AMD and CommonJS. If your factory function accepts parameters but no dependency array, the AMD environment assumes that you wish to emulate the  CommonJS module environment. The standard `require`, `exports`, and `module` variables will be injected as parameters into the factory.

Here is an example of CommonJS module format with RequireJS.

[[require_cjs]]
.Using CommonJS module format in RequireJS
[source,javascript]
----
include::include/ch7_commonjs_require.js[]
----
<1> The factory receives up to three arguments that emulate the CommonJS `require`, `exports`, and `module` variables. 

<2> Export your module rather than returning it. You can export an object in two ways - assign the the module directly to `module.exports` as shown in this snippet, or set the  properties on the `exports` object. 

<3> In CommonJS, dependencies are assigned to local variables using the `require(id)` function.

==== Loading Modules On-Demand

As per the Save Sick Child modules graph, some components shouldn't when the application starts. Similar to Mercedes Benz website example, some functionality of Save Sick Child can be loaded later when user needs it. The user might never want to visit the "Where we work" section. Hence this functionality is a good candidate for the _load on-demand_ module. You may want to load such a module on demand when the user clicks the button or selects a menu item. 

At any given time a module can be in one of three states: 

* not loaded (`module === null`)
* loading is in progress (`module === 'loading'`)
* fully loaded (`module !== null`).
+

[[load_ondemand_snippet]]
.Loading the module on demand
[source,javascript]
----
include::include/ch7_module_ondemand.js[]
---- 

<1> Checking if module loading in progress.
<2> Don't re-load the same module. If the module was already loaded just call the method to render the widget on the Web page.
<3> Setting the module into the intermediate state until it's fully loaded. 
<4> Once the `whereWeWork` module is loaded, the callback will receive the reference to this module - instantiate `whereWeWork` and render it on the page.

Let's apply the technique demonstrated in <<load_ondemand_snippet>> snippet for Save Sick Child application to lazy load the "Who We Are", "What We Do", "Where We Work" and "What To Give" modules only if the user clicked on the corresponding top bar link.

.The Main Module
[source,javascript]
----
include::include/ch7_main_module.js[]
----
<1> The first argument of the `define` function is an array of dependencies. The `!` sign in the module id string literals means that RequireJS delegates some work to a  plugin such as `order` in our example. This plugin enforces the loading order. We will talk about RequireJS plugins later in this chapter in the <<requirejs_plugins>> section.

<2> An array of modules that can be loaded on demand.

<3> Here we're using the approach described in the <<load_ondemand_snippet>> section. This factory function produces the handler for the button click event. It uses RequireJS API to load the module once the  user clicked on the button.

<4> Instantiate the click handler function using `lazyLoadingEventHandlerFactory` and assign it to the button defined in the module config.

<5> In the last step, we need to initialize each module button with the lazy loading handler.


[[requirejs_plugins]]
==== RequireJS plugins

RequireJS plugins are special modules that implement specific API. For example, the _text_ plugin allows to specify a text file as a dependency, _cs!_ translates _CoffeeScript_ files into JavaScript. The plugin's module name comes before the _!_ separator. Plugins can extend the default loader's functionality.

In the Save Sick Child application we use the _order.js_ plugin that allows to specify the exact order in which the dependencies should be loaded. You can find the full list of the available RequireJS plugins at the following https://github.com/jrburke/requirejs/wiki/Plugins[wiki page].


[[using_reuiqrejs_optimizer]]
==== Using RequireJS Optimizer

RequireJS comes with the optimization tool called http://requirejs.org/docs/optimization.html[_r.js_], which is a utility that performs module optimization. 
Earlier in this chapter, we've specified the dependencies as an array of string literals that are passed to the top-level <<REQUIRE_DESC,require>> and <<DEFINE_DESC,define>> calls. The optimizer will combine modules and their dependencies into a single file based on these dependencies.

Furthermore, r.js integrates with other optimization tools like `UglifyJS` and `Closure Compiler` to minify the content of script files. We are going to use http://gruntjs.com/[Grunt] - the JavaScript task runner. If you're not familiar with Grunt please refer <<appendix_a>> for the additional information about usage Grunt in Save Sick Child project.

Let's configure our Grunt project to enable the optimization task. Here's the command to install RequireJS, and Grunt's task packages clean, concat and uglify and save them as development dependencies in the file package.json:

.Adding dependencies to package.json
[source,bash]
----
> npm install grunt-contrib-requirejs grunt-contrib-concat grunt-contrib-clean grunt-contrib-uglify --saveDev 
----

<<rjs_gruntfile_list,The following listing>> describes the script to setup RequireJS optimizer and the related optimization tasks for Grunt. You'll need to run this script to generate optimized version of the Save Sick Child application. 

[[rjs_gruntfile_list]]
[source,javascript]
----
include::include/ch7_rjs_Gruntfile.js[]
----

<1> The +clean+ task cleans output directory. In the `files` section of task config we specify what folder should be cleaned.
<2> The +requirejs+ task. The configuration properties of +requrejs+ task are self-explanatory. +mainConfigFile+ points at the same file that <<data_main_attrib,`data-main` attribute>> of RequireJS script tag. +out+ parameter specifies output directory where optimized script will be created.
<3> The +concat+ task combines/concatenates  optimized modules code and RequireJS loader code.
<4> The +uglify+ task minifies provided files (see `src` properties) using http://lisperator.net/uglifyjs/[UglifyJS] - a compressor/minifier tool. UglifyJS produces significantly smaller version of the original script by reducing the http://en.wikipedia.org/wiki/Abstract_syntax_tree[Abstract Syntax Tree (AST)] and changing local variable names to single-letters.
<5> Loading plugins that provide necessary tasks.
<6> The default task to execute all tasks in order.

Run the http://localhost:8080/ssc-requirejs[Save Sick Child] application built with RequireJS and monitor the network traffic in Chrome Developer Tools. You'll see  many HTTP requests that load modules asynchronously. As you can see from the <<unoptim_require_fig,from following screenshot>>, 12 out of 14 browser's requests are for loading all required modules. The modules that may be loaded on demand are not here.

[[unoptim_require_fig]]
.Unoptimized version of the Save Sick Child Application
image::fig_07_02.png[]

The next <<optim_with_rjs_fig,screenshot>> shows loading of the Save Sick Child application optimized with RequireJS optimizer. We've managed to pack all our modules, their dependencies and loader's code into a single file, which considerably decreased the number of the server-side calls.

[[optim_with_rjs_fig]]
.Loading of optimized version of the Save Sick Child 
image::fig_07_03.png[]

TIP: Read more on optimization topics in the RequireJS documentation site under http://requirejs.org/docs/optimization.html[``Optimization''] section.


RequireJS took care of the optimal module loading, but you should properly arrange the inter-module communication. The Save Sick Child application doesn't have modules that heed to exchange data so we'll describe how to properly arrange inter-module communications in a separate application.

[[mediator_section]]
=== Loosely-Coupled Inter-Module Communications With Mediator

Almost any complex enterprise Web application consists of a number of components and modules.

A simple approach of arranging communications between the components is to allow all these components directly accessing public properties of each other. This would produce an application with tightly coupled components that know about each other and removal of one component could lead to multiple code changes in the application.

A better approach is to create loosely coupled components that are self-contained, do not know about one another and can communicate with the "outside world" by sending and receiving events.

Creating UI of from reusable components applying messaging techniques requires creation of loosely coupled components. Say you've created a window for a financial trader. This window gets a data push from the server showing the latest stock prices. When the trader likes the price he may click on the Buy or Sell button to initiate a trade. The trading engine can be implemented in a separate component  and establishing inter-component communications the right way is really important. 

As you've learned from Chapter 2, _Mediator_ is a behavioral design pattern that allows to unify communications of the application components. The Mediator pattern promotes the use of a single shared object that handles (mediates) communication between other objects. None of the components is aware of the others, but each of them knows about a single object - the mediator.

In Chapter 2 we've introduced an example of a small fragment of a trader's desktop. Let's reuse the same example, but this time not with `postMessage` but with the Mediator object.  

In Figure <<FIG7-6>>, the Pricing Panel on the left gets the data feed about the current prices of the IBM stock. When the user clicks on Bid or Ask button, the Pricing Panel just sends the event with the relevant trade information, e.g. a JSON-formatted string containing the stock symbol, price, buy or sell flag, date, etc.

[[FIG7-6]]
.Before the trader clicked on the Price Panel
image::fig_07_06.png[]

.After the trader clicked on the Price Panel
image::fig_07_07.png[]

Here is a HTML code snipped that implements the above scenario.

[source,html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>An example of Mediator Design Pattern</title>
    <script data-main="app/config" src="bower_components/requirejs/require.js"></script>
</head>
<body>
    <h1>mediator and RequireJS example</h1>

    <div id="pricePanel">       <!--1-->
        <p>IBM</p>
        <label for="priceInput">Bid:</label>
        <input type="text" id="priceInput" placeholder="bid price"/>

        <label for="priceInput">Ask:</label>
        <input type="text" id="priceInput" placeholder="bid price"/>
    </div>
    <div id="orderPanel">       <!--2-->
        <p id="priceText"></p>
        <label for="quantityInput">Quantity:</label>
        <input type="text" id="quantityInput" placeholder=""/>
        <button id="goButton">Go!</button>
        <button id="cancelButton">cancel</button>
    </div>

</body>
</html>
----
<1> This `div` element contains _Pricing Panel_ with Bid and Ask controls.
<2> This `div` element contains _Order Panel_ with Quantity, Go and Cancel controls.

As we stated before, we need a Mediator to handle communication between the application components. The components need to register themselves with the  Mediator so it knows about them and can route communications. The following snippet is a sample  Mediator implementation (we use `define` and `require` from RequireJS here).

[[mediator_impl]]
.The implementation of Mediator pattern.
[source,javascript]
----
include::include/ch7_mediator.js[]
----
<1> Return the private object that stores registered components.
<2> With the `Mediator.register()` function we can store components in the associative array. The Mediator is a singleton object here.
<3> Assigning the mediator instance to the component being registered.
<4> Registering component in the array using  provided `name` as key.
<5> The component can invoke `Mediator.broadcast()` when it has some information to share with other  application components.
<6> If a component has a function property with the  name matching the pattern `"on" + event`, e.g. `onClickEvent`, the Mediator will invoke this function in the context of `source` object.

The following code sample shows the main entry point of the application that uses the above mediator.    

[source,javascript]
----
include::include/ch7_mediator_usage.js[]
----
<1> Required modules will be loaded by RequireJS.
<2> Registering our components with the Mediator.
<3> Adding the `click` event listener for the Bid Price component.
<4> When the user clicks on the bid price the Mediator will broadcast the `BidClick` event to all registered component. Only the component that has this specific event handler with the name matching  the pattern `"on" + event` will receive this event.

Let's see how the code of the `PricePanel` and `OrderPanel` components looks like.  

[source,javascript]
----
include::include/ch7_pricepanel.js[]
----
<1> The setter of the Mediator object. Mediator injects its' instance during component registration (refer to <<mediator_impl>> snippet).
<2> The getter of the Mediator object.
<3> The `onBidClick` event handler. The Mediator will call this function when the `BidClick` event will be broadcast. Using getter `getMediator` we can broadcast `PlaceBid` event to all registered components. 

[source,javascript]
----
include::include/ch7_orderpanel.js[]
----
<1> The Mediator's getter and setter have the purpose similar to described in previous snippet.
<2> Defining the `PlaceBid` event handler - `onPlaceBid()`.

As you noticed, both `OrderPanel` and `PricePanel` don't know about the existence of each other, but nevertheless they can sent and receive data with the help of intermediary - the Mediator object.

The introduction of the Mediator increases reusability of components by decoupling them from each other. The Mediator pattern simplifies the maintenance of any application by centralizing the  navigational logic.

=== Summary

The size of any application tends to increase, and sooner or later you'll need to decide how to cut it into several loadable blocks of functionality. The sooner you start modularizing your application the better. 

In this chapter we've reviewed several options available for writing modular JavaScript using modern module formats. These formats have a number of advantages over using just the classical  Module Pattern. These advantages include avoiding creating global variables for each module and better support for static and dynamic dependency management.

Understanding various technologies and frameworks available in JavaScript, combined with the knowledge of different ways of linking modules and libraries is crucial for developers who want their JavaScript applications to be more responsive.
