== Large-Scale JavaScript Projects

Our Save Sick Child application is a rather small Web project. The code base of a typical enterprise Web application is a lot larger. In this chapter we'll give an example of how to build  modularized Web applications that won't bring the monolithic five megabyte application to the client's machine, but will load the code on as needed basis. We'll also give an example of how to organize the data exchange between different programming modules in a loosely coupled fashion.

People consider your web application fast for one of two reasons: either it's actually fast or it gives an impression of being fast. Ideally, you should do your best to create an web application that is very responsive. No matter how slow your web application is, it should never feel like freezing.

This chapter is about modularization techniques that will quickly render the first page of your web application on the user's Browser while loading the rest of the application in the background or on demand. We will continue refactoring the Save Sick Child application to illustrate using modules.

There is no out-of-the box modularization scheme in JavaScript language. The upcoming EcmaScript 6 specification tends to resolve this with introduction a _module concept_ in the JavaScript language itself. But it's the future.

Of course, we can load each JavaScript file using `<script>` tag. But this approach slow and error prone. Developer has to manage dependencies and loading order manually. Moreover, each `<script>` tag directive translates into an additional HTTP call to the server. As the application gets larger the latency will growth accordingly. 

// vik
<<LISTING_SCRIPT_TAG,Here is an example>> of such situation.

[[LISTING_SCRIPT_TAG]]
.With ton of `<script>` tags you can very easy lost the control of application dependencies
[source,html]
----
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8">
    
    <title>Save Sick Child | Home Page</title>
    <link rel="stylesheet" href="assets/css/styles.css">

    <script src="components/jquery.js></script>     <!-- <1> -->
    <script src="modules/deps/widget1_dep.js></script>  <!-- <2> -->
    <script src="modules/widget1.js></script>
    <script src="modules/widget2.js></script>
    <script src="modules/widget3.js></script>
    <script src="modules/deps/widget4_and_5_dep.js></script>
    <script src="modules/widget4.js></script>
    <script src="modules/widget5.js></script>
    <script src="components/widgetManager.js></script>     <!-- <3> -->

</head>
<body>
<!-- page body -->

</body>
</html>
----
<1> All widgets depend on jquery. We need to load it first.
<2> Application components might also have dependencies. Those scripts need to be loaded before component itself. Order of this script tags very important.
<3> A widgerManager component expects that all widgets (and) will be loaded.

// /vik

We need different approach to modularizing applications. We will start with using the Module Pattern to leverage Immediately-Invoked Function Expressions (IIFE) as our first step to modularization. Next, we will introduce and compare two popular JavaScript solutions and modularization patterns - CommonJS and Asynchronous Module Definition (AMD), which are alternative approaches to implementing modularization. Both CommonJS and AMD are specifications and set of APIs. In this chapter we will use http://browserify.org/[Browserify] as CommonJS implementation, and http://requirejs.org/[RequireJS] as AMD implementation.

YOu'll see how the upcoming EcmaScript 6 specification is dealing  with modules and how you can start using ES6 module syntax today with the help of third-party tools like http://corner.squareup.com/2013/02/es6-module-transpiler.html[transpiler]. The ES6 module syntax can be compiled down to existing module solutions like CommonJS or AMD.

Finally, we're going to discuss such advanced topics as intermodule-communication and Dependency Injection in JavaScript.

The code of the Save Sick Child application will be refactored to implement module system based on RequireJS for lazy loading of the  application components.

****
.Plan for chapter
* History: the Module pattern, namespaces
* CommonJS
* AMD ~70%
* https://github.com/umdjs/umd[UMD] 
* Advanced topics:
** https://gist.github.com/wycats/51c96e3adcdb3a68cbc3[ES6 modules] (http://wiki.ecmascript.org/doku.php?id=harmony:modules) and TypeScript modules
** Inter-Module communication, Mediator pattern (???)
** _Dependency Injection_
* ExtJS style (sidebar example ???)
****

=== Modularization basics

//Those are raw notes of thoughts 
//Aren't Js Files Simply Modules Already?
//Modules are pieces of code that are focused on a specific set of functionality, written using a specific pattern to facilitate modular use of the code.
//There's several approaches one can use to create modular JS.
//We'll be focusing on code that can be consumed by a module loader.

=== The Paths To Modularization

==== Module Pattern

Ultimately, it's just some code in an IIFE that:

- Returning the module value
- Augmenting the global
- Namespacing

There is one huge disadvantage of using the Module Pattern - we still need to deal with manual dependency management and manually arrange `<script>` tags in HTML page.

// TDB

==== CommonJS

// TDB
Browserify takes all of your code and concatenates it to one large file.

==== Asynchronous Module Definition (AMD)

// vik
AMD began as a draft specification for a module format on the CommonJS list but as it wasn't able to reach full concensus, further development of the format moved to the https://github.com/amdjs[amdjs Github page].

The AMD module format itself is a proposal for defining modules where both the module and dependencies can be asynchronously loaded. 

The AMD API is based on a https://github.com/amdjs/amdjs-api/wiki/AMD[specification]. The AMD API have the following main functions:

* `define` for facilitating module definition. A function takes two arguments:
** An optional array of module IDs, which serve as this module's dependencies
** A callback function (often referred to as a _factory function_), which will be invoked when dependencies are loaded, OR a value to use directory as the module's value.
+

[[LISTING_define_func]]
.Example of `define` function
[source,javascript]
----
define(
    module_id,          // <1>
    [dependencies],     // <2>
    function {}         // <3>
);
----
<1> Optional parameter, string literal defines +module_id+ that will be used by AMD loader to load this module.
<2> Optional array of dependencies' ids.
<3> Function for instantiating the module or object.
+

[[LISTING_define_modeule]]
.Definition of `wayToGive` module
[source,javascript]
----
include::include/ch7_define_wayToGive.js[]
----
<1> In this example, we not providing optional +module_id+. File name without `.js` extension will be used as +module_id+. Our module has one dependency on module called +newContentLoader+. Module instance will be passed in factory method as variable +contentLoader+. 
<2> We can start use dependency object immediately. AMD loader have taken care of loading and instantiation of this dependency.
<3> Module defines and returns constructor function for new objects.

* `require` function takes two arguments
** An array of module IDs to load. Module ID is a string literal.
** A callback to be executed once those modules are available. The modules loaded by ID are passed into the callback in their relative positions. <<LISTING_Require_func,Here is example>> of `require` function usage.
+

[[LISTING_require_func]]
.Example of `require` function usage
[source,javascript]
----
require(["main"], function() {
    console.log("module main is loaded");
}); // <1>
----
<1> Loads module with id +main+ and executes anonymous function after module and all its dependencies are loaded.

`exports` 

Distinctions from CommonJS

//TBD

AMD pros:

* Very simple API (two functions - `require` and `define`). 
* Wide variety of loaders available. We will talk about loaded later in <<REQUIREJS, RequireJS section>>.
* Plugins offer an immense amount of flexibility
* Easy To Debug.
+

Consider following error messages that JavaScript interpretor can throw:
+

_There was an error in /modules/loginModule.js on line 42_
+

*vs*
+

_There was an error in /built-app.js on line 1984._
+

When your application if modularized you can much easy identify error and eliminate it.

* Performance: when you not require the module it's not loaded.
+

We might want to load module on demand, for example, on a button click. In following example, module can be in three states: not loaded (`module === null`), loading in progress (`module === 'loading'`), fully loaded (`module !== null`).
+

.Loading +widget1+ module on demand
[source,javascript]
----
var module;
var buttonClickHandler = function(event) {
  if (module === "loading") {       // <1>
    return;
  }
  if (module !== null) {        // <2>
    module.render();
  } else {
    module = "loading";         // <3>
    require(["modules/widget1"], function(moduleObject) { // <4>
      module = new moduleObject();      
      module.render();
    });
  }
};
----
<1> Checking if a module loading in progress.
<2> We don't want to load module each time. If module was loaded just call method to render widget on the page.
<3> Setting module into intermediate state until it will be fully loaded. 
<4> Once module loaded, we can instantiate new widget object and render it in the page.

AMD cons:

* The dependency array can get rather large for complex modules (Example TBD).
* Easy to get a mismatch between dependency array and callback arguments (Example TBD).

[[REQUIREJS]]
===== RequireJS

After discussion of theory and basics of AMD it is time to see how modularization works in real life. In this section we're introduce AMD-complaint module loader http://requirejs.org/[RequireJS]. 
RequireJS (include info about build with `r.js`)

****
http://github.com/cujojs/curl[*curl.js*]
Sidebar about curljs - another popular AMD complaint module loader.
TBD
****

You can download +require.js+ for github repo of use package manager like Bower.

// TBD about Bower

.Adding RequireJS to the web page
[source,html]
----
<!DOCTYPE html>
<head>
    <!-- content omitted -->
</head>
<body>
<!-- page body -->

<script src="components/requirejs/require.js" 
        data-main="app/config"></script> <!-- 1 -->

</body>
</html>
----
<1> A `data-main` attribute needs for require.js. It specifies that framework should load `app/config.js` after +require.js+ loads. `app/config.js` is an entry point of your application.

// /vik

==== Universal Module Definition (UMD)

Series of patterns to support multiple modules formats.
https://github.com/umdjs/umd[Specification]

=== Summary

// vik

The chances are high that your application size will increase, and sooner or later you'll need to decide how to cut it into many reusable blocks of functionality The sooner you start planning for modularizing your application, the better. 

In this chapter we've reviewed several of the options available for writing modular JavaScript using modern module formats. These formats have a number of advantages over using the (classical) module pattern alone including: avoiding a need for developers to create global variables for each module they create, better support for static and dynamic dependency management.

Understanding what technologies and frameworks available in JavaScript, combined with the knowledge of different ways of linking modules and libraries to your main application, is crucial for the creation of responsive and fast JavaScript applications.

// /vik