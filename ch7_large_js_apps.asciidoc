:toc:
:toclevels: 4
:icons: font
:imagesdir: ./images

== Large-Scale JavaScript Projects

Reducing the  startup latency and implementing lazy loading of certain parts of the application are the main reasons for modularization. A good illustration of why you may want to consider cutting the code into pieces is a well designed Web application of the http://www.mbusa.com/[Mercedes Benz USA]. This Web application serves people who live in America and either own or consider purchasing cars from this European car manufacturer.

One of the options to purchase a vehicle is called European Delivery. An American resident can combine car purchase with a vacation. She would fly to Europe to the Mercedes Benz factory, pick up the car there and then she would be vacationing for two weeks driving her new vehicle in Europe. After the vacation is over, this car would be shipped to her home town in the USA.  This really nice program  would have added several thousand dollars to the price of the car.

From the application design code of view, we don't need to include the code that supports the European Delivery to each and every user's who decided to visit mbusa.com. _If and only if_ the user visits the menu Owners and clicks on the European Delivery link, then the required code and resources have to be pushed to the user's computer or mobile device. The snapshot in <<FIG7-1>> was taken after clicking on this link with Chrome Developer tools panel open.

[[FIG7-1]]
.MB USA: Europian Delivery 
image::fig_07_01.png[image]

As you see, _1.9Mb_ worth of code and other resources have been downloaded as a result of this click. Should the application architects of the MB USA decided to bring this code to the user's device on the initial load of http://mbusa.com, the wait time would increase by another second or more. This  is unnecessary because only a tiny number of American drivers would be interested in exploring the European Delivery option. This example illustrates the use case where modularization and lazy loading is needed.

Our Save Sick Child application is not as big as the Mercedes Benz site. But we'll use it to give you an example of how to build modularized Web applications that won't bring the large and monolithic application to the client's machine, but will load the code on as needed basis. We'll also give an example of how to organize the data exchange between different programming modules in a loosely coupled fashion.

Users consider a Web application fast for one of two reasons: either it's actually fast or it gives an impression of being fast. Ideally, you should do your best to create a Web application that's very responsive. 

TIP: No matter how slow your Web application is, it should never feel like it's being frozen.

This chapter is about modularization techniques that will allow quick rendering of the first page of your Web application by the user's browser while loading the rest of the application in the background or on demand. We will continue refactoring the Save Sick Child application to illustrate using modules.

=== Modularization basics

Modules are code fragments that implement certain   functionality written using a specific techniques. There is no out-of-the box modularization scheme in JavaScript language. The upcoming ECMAScript 6 specification tends to resolve this by introducing the _module concept_ in the JavaScript language itself. This is the future. 

You may ask, "Aren't .js files modules already?" Of course, you can include and load each JavaScript file using the `<script>` tag. But this approach is error prone and slow. Developers have to manually manage dependencies and file loading order. Moreover, each `<script>` tag results in the  additional HTTP call to the server.

As the application gets larger the number of script files grows accordingly, which is illustrated in the following 
<<LISTING_SCRIPT_TAG, code sample>>.


[[LISTING_SCRIPT_TAG]]
.Multiple `<script>` tags complicate controlling  application dependencies
[source,html]
----
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8">
    
    <title>Save Sick Child | Home Page</title>
    <link rel="stylesheet" href="assets/css/styles.css">

    <script src="components/jquery.js></script>     <!-- <1> -->

    <script type="text/javascript" src="app/modules/utils/load-html-content.js"></script>
    <script type="text/javascript" src="app/modules/utils/show-hide-div.js"></script>
    <script type="text/javascript" src="app/modules/svg-pie-chart.js"></script>
    <script type="text/javascript" src="app/modules/donation.js"></script>
    <script type="text/javascript" src="app/modules/login.js"></script>
    <script type="text/javascript" src="app/modules/utils/new-content-loader.js"></script>
    <script type="text/javascript" src="app/modules/generic-module.js"></script>
    <script type="text/javascript" src="app/modules/module1.js"></script> <!-- <2> --> 
    <script type="text/javascript" src="app/modules/module2.js"></script>
    <script type="text/javascript" src="app/config.js"></script>
    <script type="text/javascript" src="app/main.js"></script> <!-- <3> -->

</head>
<body>
<!-- page body -->

</body>
</html>
----
<1> Loading the jQuery first because all other modules depend on it.

<2> Other application components may also have internal dependencies on other scripts. Those scripts need to be loaded before the respective components. Having the proper order of these script tags is very important.

<3> The script for the main Web page should be loaded after all dependencies have finished loading.

We need other than adding `<script>` tags approach to modularizing applications. Let's start with using the Module pattern to leverage so called Immediately-Invoked Function Expressions (IIFE) as the first step to modularization. Next, we'll introduce and compare two popular JavaScript solutions and modularization patterns - CommonJS and Asynchronous Module Definition (AMD), which are alternative approaches to modularization. Both CommonJS and AMD are specifications defining sets of APIs. 

You'll learn pros and cons of both formats later in the chapter, but the AMD module format plays nicely with the asynchronous nature of Web. In this chapter you'll see the use of the AMD module format and http://requirejs.org/[RequireJS] framework to implement the modularized version of the Save Sick Child application.

Also, you'll see how to use the RequireJS APIs to implement on-demand loading of the application components (e.g. What We Do, Ways To Give et al.)

The upcoming ECMAScript 6 specification suggests how to handle modules, and how to start using ES6 module syntax today with the help of third-party tools like http://corner.squareup.com/2013/02/es6-module-transpiler.html[transpiler]. The ES6 module syntax can be compiled down to existing module solutions like CommonJS or AMD. You can find more details about CommonJS, AMD and the ES6 module format in the corresponding sections of this chapter.

After application modules are asynchronously loaded, they need to communicate to each other. You can explicitly specify the components dependencies, which is fine as long as you have a handful of  components. A more generic approach is to handle inter-module communications in a loosely coupled fashion using the _Mediator_ pattern, CommonJS or AMD formats. By _loosely coupled_ we mean that components are not aware of each other's existence.

The next section reviews various approaches and patterns of modular JavaScript applications.

=== Roads To Modularization

Although JavaScript has no build-in language support of modules, the developers' community has managed to find a way for modularization using existing syntax constructs, libraries and conventions to emulate modules-like behavior. The _Module pattern_ doesn't require any additional frameworks and works in any JavaScript environment. The _CommonJS_ module format is widely adopted for the server-side JavaSctipt, while the _AMD_ format is popular in the applications running in Web browsers. 

==== The Module Pattern

In software engineering, the Module pattern was originally defined as a way to implement encapsulation of reusable code. In JavaScript, the Module pattern is used to emulate the concept of classes. We're able to include both public and private methods as well as variables inside the single object, thus hiding the encapsulated code from other global scope objects. Such encapsulation lowers the likelihood of conflicting function names defined in different scripts that could be used in the same application's scope.

Ultimately, it's just some code in an IIFE that creates a module object in the internal scope of a function and exposes this module to the global scope using the JavaScript language syntax. Consider the following three code samples illustrating how the Module pattern could be implemented using IIFEs.

.Returning the value from a module 
[source,javascript]
----
include::include/ch7_iife_loginModule.js[]
----
<1> Assigning the module object that was created in the closure to the variable `loginModule`.
<2> Because of the JavaScript's function scoping, other parts of the code can't access the code inside the closure. With this approach you can implement encapsulation and private members.

.Injecting the module into the global object 
[source,javascript]
----
include::include/ch7_iife_global_loginModule.js[]
----
<1> Instead of exporting the module to a variable as in the previous example, we're passing the global object as a parameter inside the closure.
<2> Attaching the newly created object to the global object. After that the `loginModule` object can be accessed from the external application code as `window.loginModule` or just `loginModule`.

.Introducing namespaces in the global object
[source,javascript]
----
include::include/ch7_iife_namespace_loginModule.js[]
----
<1> Here we have modification of the approach described in previous snippet. To avoid name conflicts, create a namespace for our application called `ssc`. Note that we check for this object existence in the next line.
<2> Now we can logically structure application code using namespaces. The global `ssc` object will contain only the code related to the Save Sick Child application.

The Module patterns works well for implementing encapsulation in a rather small applications. It's easy to implement and is frameworks agnostic. However this approach doesn't scale well because when working with an application with the large number of modules you may find yourself adding lots of boilerplate code checking objects' existence in the global scope for each new module. Also, you need to be careful with managing namespaces: since you are the one who put an object into the global scope, you need to think  how to avoid accidental names conflicts.

The Module pattern has a serious drawback - you  still need to deal with manual dependency management and manually arrange `<script>` tags in the HTML document. 

==== CommonJS

http://www.commonjs.org/[CommonJS] is an effort to standardize JavaScript APIs. People who work on CommonJS APIs have attempted to develop standards for both modules and packages. The CommonJS module proposal specifies a simple API for declaring modules, but mainly on the server-side. The CommonJS module format was optimized for non-browser environments since the early days of the server-side JavaScript.

On the Web browser side, you always need to consider potentially slow HTTP communications, which is not the case on the server. One of the solutions suitable for browsers is to concatenate all scripts into a handful of bundles to decrease the number of HTTP calls, which was not a concern for the server-side JavaScript engines because file access is nearly instantaneous. On the server side separation of the code allowed to dedicate each file to exactly one module for ease development, testing and maintainability.

In brief, the CommonJS specification requires the environment to have  http://wiki.commonjs.org/wiki/Modules/1.1#Module_Context[three free variables]: `require`, `exports`, and `module`. The syntax to define the module is called _authoring format_. To make the module loadable by a Web browser it has to be transformed into _transport format_. 

[source,javascript]
----
include::include/ch7_commonjs.js[]
----
<1> If a module requires other modules, declare references to those modules inside the current module's scope by using the `require` function. You need to call `require(id)` for each module it  depends on.  The module id has slashes defining the file path or a URL to indicate namespaces for external modules. Modules are grouped into a packages.

<2> The `exports` object exposes the public API of a module. All objects, functions, constructors that your module exposes must be declared as properties of the `exports` object. The rest of the module's code won't be exposed.

<3> The `module` variable provides the metadata about the module. It holds such properties as `id` and a unique `uri` of each module. The `module.export` exposes `exports` object as its property. Because objects in JavaScript are passed as references, the `exports` and `module.exports` point at the same object.

WARNING: The snippet above may give you an impression that the module's code is executed in the global scope, but it's not. Each module is executed in its own scope which helps to isolate them. This works automatically when you write modules for NodeJS environment running on the server (see Chapter 8). But to use CommonJS module format in the Web browser you need to use an extra tool to generate transport format from _authoring format_. http://browserify.org/[Browserify] takes all your scripts and concatenates them it to one large file.  Besides the module's code the generated transport bundle will contain the boilerplate code that provides CommonJS modules runtime support in the browser environment. This build step complicates the development workflow. Usually developers perform the _code/save/refresh browser_ routine, but it doesn't work in this case and requires an extra steps as you need to install the additional build tool and write  build scripts. 


[underline]#CommonJS pros:#

* It's a simple API for writing and using modules.
* Such a pattern of organizing  modules is widespread in the server-side JavaScript, e.g. NodeJS.

[underline]#CommonJS cons:#

* Web browsers don't automatically create the scoped variables `require`, `exports`, `module` hence the additional build step is required.
* The `require` method is synchronous, but there is no exact indication if dependent module's values are fully loaded because of the asynchronous nature of Web browsers. There is no event to notify the application that 100% of the required resources is loaded. 
* CommonJS API is suitable for loading +.js+ files, but it can't load other assets like CSS and HTML.

NOTE: If you want to write modules in the format that can be used in both browser and server's  environments read our suggestions in the  <<umd>> section on this chapter.

Further reading:

* http://wiki.commonjs.org/wiki/Modules/1.1[CommonJS Modules 1.1 specification]
* http://nodejs.org/docs/latest/api/modules.html#modules_modules[Node.js Modules Reference]


[[amd_section]]
==== Asynchronous Module Definition

AMD began as a draft specification for module format in CommonJS, but since the full agreement about its content was not reached, the further work on module's format moved to the https://github.com/amdjs[amdjs Github page].

The AMD module format itself is a proposal for defining modules where both the module and dependencies can be asynchronously loaded. 
The AMD API is based on https://github.com/amdjs/amdjs-api/wiki/AMD[this specification]. The AMD API have the following main functions:

[[DEFINE_DESC]]
* `define` for facilitating module definition. This function takes tree arguments:
** The optional module id
** An optional array of modules' IDs of dependencies
** A callback function (a.k.a _factory function_), which will be invoked when dependencies are loaded. 
+

[[LISTING_define_func]]
.The signature of a `define` function
[source,javascript]
----
define(
    module_id,          // <1>
    [dependencies],     // <2>
    function {}         // <3>
);
----
<1> This string literal defines +module_id+ that will be used by the AMD loader for loading this module.
<2> An optional array of dependencies' ids.
<3> The function for instantiating the module or object. The factory function will only be executed once
+

For example, the Save Sick Child application has a menu Way To Give, which in turn depends on other module called `otherContent`. If the user clicks on this menu, we can load the module that can be defined in the +wayToGive.js+ as follows:
+

[[LISTING_define_modeule]]
.The definition of the wayToGive module
[source,javascript]
----
include::include/ch7_define_wayToGive.js[]
----
<1> This code doesn't have the optional +module_id+. The loader will use the file name without the `.js` extension as +module_id+. Our module has one dependency on the module called +otherContent+. The dependent module instance will be passed in the factory method as variable +otherContent+. 
<2> We can start using the dependency object immediately. AMD loader have taken care of loading and instantiation of this dependency.
<3> The module returns constructor function to be used for creation of new objects.

[[REQUIRE_DESC]]
* The `require` function takes two arguments
** An array of module IDs to load. Module ID is a string literal.
** A callback to be executed once those modules are available. The modules loaded by IDs are passed into the callback in order. <<LISTING_Require_func,Here is example>> of the `require` function usage.
+

[[LISTING_require_func]]
.The example of `require` function usage
[source,javascript]
----
require(["main"], function() {
    console.log("module main is loaded");
}); 
----

[underline]#AMD pros:#

* It's a very simple API that has only two functions - `require` and `define`. 

* A wide variety of loaders is available. You'll find more coverage on loaders in the <<REQUIREJS, RequireJS section>>.

* A CommonJS module authoring format is supported by the majority of loaders. You'll see an example of modules later in the <<require_cjs>> section. 


* Plugins offer an immense amount of flexibility.

* AMD is easy to debug.
+

Consider the following error messages that JavaScript interpreter may throw:
+

_There was an error in +/modules/loginModule.js+ on line_ *42*
+

*vs*
+

_There was an error in +/built-app.js+ on line_ *1984*
+

In modularized applications you can easier localize errors.

* Performance: module are loaded only when required hence the initial portion of the application's code become smaller.

[underline]#AMD Cons:#

* The dependency array can get rather large for complex modules.
+

[source,javascript]
----
include::include/ch7_define_large_array_of_deps.js[]
----
<1> In the real-world enterprise applications the array of dependency modules might be pretty large.

* Human errors can result in mismatch between dependency array and callback arguments.
+

[source,javascript]
----
include::include/ch7_define_module_ids_order.js[]
----
<1>  The mismatch of module IDs and factory function arguments will cause module usage problems.


[[umd]]
==== Universal Module Definition

Universal Module Definition (UMD) is a series of patterns and code snippets that provide compatibility boilerplate to make modules environment-independent. Those patterns can be used to support multiple module formats. Here is an example of the module definition in UMD notation. In the following example, the module can be used with the AMD loader and as one of the variations of the Module Pattern.


[source,javascript]
----
include::include/ch7_umd_amd_globals.js[]
----
<1> If the AMD loader is available proceed with defining the module according to AMD specification.

<2> If the AMD loader isn't present, use the factory method to instantiate the object and attach it to the `window` object.

<3> Passing the top-level context and providing a implementation of a factory function.

It's worth mentioning that UMD is not a specification or a standard. You need to pay attention to UMD patterns in case when your modules will run in more than one type of environment (e.g. a Web browser and on the server side engine running NodeJS). In most cases, it makes a lot of sense to use a single module format.

You can find more information about UMD and commented code snippets for different situations in https://github.com/umdjs/umd[the UMD project repository].

==== ECMAScript 6 Modules

The ECMAScript 6 (ES6) specification is an evolving draft outlining changes and features for the next version of JavaScript. This specification will be finalized soon, but before that happens the browsers' support for anything defined in ES6 will be experimental at best and cannot be relied upon for Web applications that must run in multiple browsers. One of the most important features of the upcoming ES6 specification is the _module syntax_. Here is an example of how it suggests to define and use a module:

.Login module definition
[source,javascript]
----
export function login(userNameValue, userPasswordValue) { // <1>
    console.log("login implementation omitted");
};
----
<1> A keyword `export` used to precify what function or object will be exposed.

And this is how can be used:

.Main application module
[source,javascript]
----
import login from 'login'
var result = login("admin", "password");
----

.ES6 module transpilers
****
Although ES6 standard features are not implemented yet by most of browsers you can use the third party tools to get a flavor of upcoming enhancements in JavaScript language. http://corner.squareup.com/2013/02/es6-module-transpiler.html[ES6 transpiler] developed by the http://squareup.com/[Square] Engineers helps using the module authoring syntax from ES6 and compile it down to the transport formats that you learned earlier in this chapter.

Consider the following example. 

.A `circle.js` module
[source, javascript]
----
export function area(radius) { 
  return Math.PI * radius * radius;
}

export function circumference(radius) { 
  return 2 * Math.PI * radius;
}
----
The above module exports two functions: `area()` and `circumference()`.

.The `main.js` uses functions from `circle.js` module
[source, javascript]
----
import { area, circumference } from 'circle';     // <1>

console.log("Area of the circle: " + area(2) + " meter squared");   // <2>
console.log("Circumference of the circle: " + circumference(5) + " meters");
----
<1> The `import` keyword specifies the objects we want to use from the module.
<2> Sample use of the imported functions

Now, using ES6 transpiler command

----
compile-modules circle.js --type amd --to ../js/  #<1>
compile-modules main.js --type amd --to ../js/
----
<1> With the `type` command line switch we can specify that output format will be: _amd_, _cjs_ and _globals_.

we compile those modules to:

* *CommonJS* format
+

[source,javascript]
----
"use strict";

function area(radius) {
    return Math.PI * radius * radius;
}

function circumference(radius) {
    return 2 * Math.PI * radius;
}
exports.area = area;
exports.circumference = circumference;
----
+

.main.js
[source,javascript]
----
"use strict";
var __dependency1__ = require("circle");
var area = __dependency1__.area;
var circumference = __dependency1__.circumference;

console.log("Area of the circle: " + area(2) + " meter squared");
console.log("Circumference of the circle: " + circumference(5) + " meters");
----

* *AMD* format
+

.circle.js
[source,javascript]
----
define("circle", ["exports"],
    function(__exports__) {
        "use strict";

        function area(radius) {
            return Math.PI * radius * radius;
        }

        function circumference(radius) {
            return 2 * Math.PI * radius;
        }
        __exports__.area = area;
        __exports__.circumference = circumference;
    });
----
+

.main.js
[source,javascript]
----
define("main", ["circle"],
    function(__dependency1__) {
        "use strict";
        var area = __dependency1__.area;
        var circumference = __dependency1__.circumference;

        console.log("Area of the circle: " + area(2) + " meter squared");
        console.log("Circumference of the circle: " + circumference(5) + " meters");

    });
----

* Browser globals
+

.circle.js
[source,javascript]
----
(function(exports) {
    "use strict";

    function area(radius) {
        return Math.PI * radius * radius;
    }

    function circumference(radius) {
        return 2 * Math.PI * radius;
    }
    exports.circle.area = area;
    exports.circle.circumference = circumference;
})(window);
----
+

.main.js
[source,javascript]
----
(function(circle) {
    "use strict";
    var area = circle.area;
    var circumference = circle.circumference;

    console.log("Area of the circle: " + area(2) + " meter squared");
    console.log("Circumference of the circle: " + circumference(5) + " meters");

})(window.circle);

----

To learn what features of ECMAScript 6 are supported on browsers you can visit http://kangax.github.io/es5-compat-table/es6/[ECMAScript 6 compatibility table].

NOTE: http://www.typescriptlang.org/[TypeScript] - a modern open-source language from Microsoft what compiles to JavaScript - tends to bring object-oriented concepts like classes and modules to JavaScript. It has a module syntax of which is very similar that upcoming ES6 standard proposed. TypeScript compiler can produce CommonJS and AMD module formats. you can learn more about TypeScript from http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf[language specification]. You can find Save Sick Child application written in TypeScript in Appendix X (????)

****


[[REQUIREJS]]
=== Mincing the Save Sick Child Application Into Modules

Now that you know the basics of AMD and different modularization patterns, let's  modularize our Save Sick Child application. In this section we'll apply the AMD-complaint module loader - the framework http://requirejs.org/[RequireJS].

TIP: http://github.com/cujojs/curl[curl.js] is another AMD-compliant asynchronous loader. curl.js and RequireJS are very similar frameworks. To learn differences between them you can follow https://groups.google.com/forum/#!topic/requirejs/niUyLZrivgs[this thread on RequireJS group]. In this thread you can find answers of the developers of RequireJS (James Burke) and curl.js (John Hann).

Let's start with brief explanation of the directory structure of the modularized Save Sick Child.

[[ssc_structure]]
.A directory structure of Save Sick Child
image::fig_07_05.png[align="center"]

1. All application's JavaScript files reside in the _app/modules_ directory.
+

Inside the _modules_ directory you can have as many nested folders as you want, e.g. _utils_ folder.

2. The application assests remain the same as in previous chapters.
3. We keep all Bower-managed dependencies in the _components_ directory: RequireJS and its plugins, jQuery etc. For more details on Bower please read <<what_is_bower>> sidebar.
4. The _dist_  directory will serve as the location for the optimized version of our application. We will cover optimization with `r.js` later in <<using_reuiqrejs_optimizer>> section.
5. The QUnit/Jasmine tests will live in the _test_ directory. Testing will be covered in the next chapter <<tdd_with_javasctipt>>. 

You can download require.js from its github repository or use a package manager like <<what_is_bower,Bower>>.

[[what_is_bower]]
.What is *Bower*?
****
https://github.com/bower/bower[Bower] is a package manager for the web projects. Twitter has  donated it to the open-source community. Bower is a utility and a community driven repository of libraries and frameworks for front-end development. Bower's idea is very similar to NPM, but the latter is more suitable for the server-side projects. Bower was designed and implemented to handle dependencies for web projects.

Bower will take care of transitive (dependency of a dependency) dependencies and download all required library components. Each Bower package has bower.json file, which contains the package metadata for managing the package's transitive dependencies. Also, bower.json can contain information about the package repository, readme file, license et al. You can find bower.json in the root directory of the package. For example, the path _components/requirejs/bower.json_ is a path for the RequireJS metadata file. Bower can installed via NPM. The following line shows how to install Bower globally in your system.

[source,bash]
----
npm install -g bower    
----

Next you can start using Bower. For example, here is a Bower's command to install RequireJS.

[source,bash]
----
bower install requirejs --save 
----
Bower installs RequireJS into _components/requirejs_ directory and saves information about dependencies in bower.json configuration file.

Bower, as well as NPM, simplifies delivery of dependencies into target platform. Which means that you don't necessarily need to store dependencies of your application next to a application files in the source code repository. 


If you're not sure if you need to check your JavaScript dependencies under the source control, read the http://addyosmani.com/blog/checking-in-front-end-dependencies/[article by Addi Osmani] that covers this subject.

Your application could have its own file bower.json with the list of the dependencies. At this point, Bower can install all required application dependencies with one command - `bower install`. And you can find all your dependency files in +components+ directory. Here is the content of the file bower.json for our Save Sick Child application. 

[source,javascript]
----
{
  "name": "ch7_dynamic_modules",
  "description": "Chapter 7: Save Sick Child, Dynamic Modules app",
  "dependencies": {
    "requirejs": "~2.1.5",
    "jquery": ">= 1.8.0",
    "qunit": "~1.11.0",
    "modernizr": "~2.6.2",
    "requirejs-google-maps": "latest"
  }
}
----

Application dependencies are specified in corresponding "dependencies section.

[[application_components]]
.Directory structure of application's components
image::fig_07_04.png[align="center"]

Also, there is a http://sindresorhus.com/bower-components/[Bower search tool] to find desired component in repository.

****

Once RequireJS downloaded and placed into the project directory, add it to the html file as demonstrated in <<add_requirejs>> snippet.

[[add_requirejs]]
.Adding RequireJS to the web page
[source,html]
----
<!DOCTYPE html>
<head>
    <!-- content omitted -->
</head>
<body>
<!-- page body -->

<script src="components/requirejs/require.js" 
        data-main="app/config"></script> <!-- <1> -->

</body>
</html>
----
[[data_main_attrib]]
<1> Once the RequireJS library is loaded it will look for the `data-main` attribute and attempt to load the `app/config.js` script asynchronously. The `app/config.js` is the entry point of our application.


[[inside_config]]
==== Inside config.js

RequiredJS uses a configuration object that includes that modules and dependencies that have to be managed by the framework.

[source,javascript]
----
include::include/ch7_require_config.js[]
----
<1> http://requirejs.org/docs/api.html#config[RequireJS Documentation] has a comprehensive overview of all configuration options. We've included some of them here. 

<2> The `paths` configuration option defines the mapping for module names and its paths. The `paths` is used for module names and shouldn't contain file extensions.

<3> After configuring the modules' paths we're loading the 'main' module. The navigation of our application flow starts there.


==== Writing Modules

Let's take a closer look at the module's internals that make it consumable by the RequireJS module loader.


[source,javascript]
----
include::include/ch7_module_contentLoader.js[]
----
<1> As we discussed in the <<amd_section>> section, the code that you want to expose as a module should be wrapped in the `define()` function call. The first parameter is an array of dependencies. The location of dependencies files we're defined <<inside_config>>. The dependency object doesn't have the same name as the dependency string id. The most important is order that dependency objects are passed to factory function. The order should be the same as the order in the dependencies array.

<2> In this module we export only in the constructor function that returns object that uses _render_ function to draw the visual component on the screen. In our case, this is part of HTML file with text for specific module. 

<3> The `contentLoader` object loaded from _app/modules/util/new-content-loader.js_ (refer the _config.js_), instantiated by RequireJS and is ready to use. 

RequreJS also supports the CommonJS module format with a slightly different signature of `define()` function. This helps to bridge the gap between AMD and CommonJS. If your factory function accepts parameters but you omit the dependency array, the AMD environment assumes you wish to emulate a CommonJS module environment. The standard `require`, `exports`, and `module` variables are injected as parameters to the factory.

Here is an example of CommonJS module format with RequireJS.

[[require_cjs]]
.Using CommonJS module format in RequireJS
[source,javascript]
----
include::include/ch7_commonjs_require.js[]
----
<1> The factory receives up to three arguments that emulate the CommonJS `require`, `exports`, and `module` variables. 

<2> You should export your module rather than returning it. You can export an object in two ways - assign the the module directly to `module.exports` as shown in this snippet, or set the  properties on the `exports` object. 

<3> In CommonJS, dependencies are assigned to local variables using the `require(id)` function.

==== Loading Modules On-Demand

A couple of components of our application don't necessarily need to be loaded at the time when the  application starts. Similar to Mercedes Benz website example, some functionality of Save Sick Child can be loaded later when user needs it. For example, the user might never want to visit the "Where we work" section. Hence this functionality is a great candidate for the "load on-demand" module. You may want to load a module on demand when the user clicks the button or selects a menu item. The module can be in one of three states: 

* not loaded (`module === null`)
* loading in progress (`module === 'loading'`)
* fully loaded (`module !== null`).
+

[[load_ondemand_snippet]]
.Loading widget1 module on demand
[source,javascript]
----
include::include/ch7_module_ondemand.js[]
----

<1> Checking if module loading in progress.
<2> Don't re-load the same module. If the module was already loaded just call the method to render the widget on the Web page.
<3> Setting the module into the intermediate state until it's fully loaded. 
<4> Once the module is loaded, instantiate the new widget object and render it on the page.

Let's apply technique demonstrated in <<load_ondemand_snippet>> snippet for Save Sich Child application to load the "Who We Are", "What We Do", "Where We Work" and "What To Give" sections only if the user clicked on the corresponding top bar link.

.The Main Module
[source,javascript]
----
include::include/ch7_main_module.js[]
----
<1> The first argument of the `define` function receives the array of dependencies.
+

The `!` sign in the module id string literals means that RequireJS delegates some work to a  plugin - it's `order` in our example. This plugin enforces the loading order. We will talk about RequireJS plugins later in this chapter in the <<requirejs_plugins>> section.

<2> An array of modules that can be loaded on demand.

<3> Here we're using approach that we described in <<load_ondemand_snippet>> section. This factory function produces button on-click handler. It uses RequireJS API to load the module once user clicked button.

<4> Instantiate the click handler and apply it to button defined in module config.

<5> On the last step, we need to initialize each module button with the lazy loading handler.


[[requirejs_plugins]]
==== RequireJS plugins

RequireJS plugins are special modules that implement a specific API. Plugins can extend the default loader's functionality. For example, the _text_ plugin allows to specify a text file as a dependency, _cs!_ translates _CoffeeScript_ files into JavaScript. The plugin's module name comes before the _!_ separator.

In the Save Sick Child application we use _async.js_ and _order.js_ plugins. _Async_ is the  plugin for loading Google Maps dependency asynchronously. The _order_ is a plugin that allows to specify the exact order in which the dependencies should be loaded.

You can find the full list of the available RequireJS plugins at the following https://github.com/jrburke/requirejs/wiki/Plugins[wiki page].


[[using_reuiqrejs_optimizer]]
==== Using RequireJS Optimizer

RequireJS comes with the optimization tool called http://requirejs.org/docs/optimization.html[_r.js_], which is a utility that does optimization of modules. 

Earlier in this chapter, we've specified the dependencies as array of string literals that are passed to top-level <<REQUIRE_DESC,require>> and <<DEFINE_DESC,define>> calls. The optimizer will combine modules and their dependencies into a single file based on these dependencies.

Furthermore, r.js integrates with other optimization tools like `UglifyJS` and `Closure Compiler` to minify the content of script files.

*TODO*: _Make introduction of Grunt Tools in this chapter not next chapter._ 

Let's configure our Grunt project to enable optimization task. Here'e the command to install requirejs, clean, concat and uglify grunt tasks packages and save them as development dependency in package.json:

.Add RequireJS dependency to package.json
[source,bash]
----
> npm install grunt-contrib-requirejs grunt-contrib-concat grunt-contrib-clean grunt-contrib-uglify --saveDev 
----

<<rjs_gruntfile_list,Following listing>> describes how to setup RequireJS optimizer and related optimization tasks for Grunt.

[[rjs_gruntfile_list]]
[source,javascript]
----
include::include/ch7_rjs_Gruntfile.js[]
----

<1> The +clean+ task cleans output directory. In the `files` section of task config we specify what folder should be cleaned.
<2> The +requirejs+ task. The configuration properties of +requrejs+ task are self-explanatory. +mainConfigFile+ points at the same file that <<data_main_attrib,`data-main` attribute>> of RequireJS script tag. +out+ parameter specifies output directory where optimized script will be created.
<3> The +concat+ task combines/concatenates together optimized modules code and RequireJS loader code.
<4> The +uglify+ task minifies provided files using http://lisperator.net/uglifyjs/[UglifyJS] - a compressor/minifier tool. UglifyJS produces significantly smaller version of original script by reducing Abstract Source Tree (AST) and mangling local variable to single-letters.
<5> Loading plugins that provide necessary tasks.
<6> The default task to execute all tasks in order.

Run the Save Sick Child application built with RequireJS and monitor the network traffic in Chrome Developer Tools, and you'll see  many HTTP requests that load modules asynchronously. As you can see from the <<unoptim_require_fig,from following screenshot>>, 12 out of 14 requests that browser sends are for loading all required modules.

[[unoptim_require_fig]]
.Unoptimized version of the Save Sick Child Application
image::fig_07_02.png[]

The next <<optim_with_rjs_fig,screenshot>> shows loading of the Save Sick Child application optimized with RequireJS optimizer. We managed to pack all our modules, its dependencies and loader's code into a single file, which considerably decreased the number of server-side calls.

[[optim_with_rjs_fig]]
.Loading of optimized version of the Save Sick Child 
image::fig_07_03.png[]

You can find more information about different optimization topics on the RequireJS documentation site under http://requirejs.org/docs/optimization.html[``Optimization''] section.

[[mediator_section]]
=== Handling inter-module communications with Mediator Design Pattern

Almost any complex screen of a enterprise application consists of a number of components and modules.

A low hanging approach to arrange communication between the components is to just put all these components on the page and program direct communications among these components. This would produce a monolithic application with tightly coupled components that know about each other and where removal of one component would lead to multiple code changes in the application.

The better approach is to create loosely coupled components that are self-contained, do not know about one another's existence, and can communicate with the "outside world" by sending and receiving events.

Creating the UI of from reusable components applying messaging techniques requires creation of  loosely coupled components. Say you've created a window for a financial trader. This window get the data push from the server showing the latest stock prices. When the trader likes the price he may click on the Buy or Sell button to initiate a trade. The trading engine can be implemented in a separate  window and establishing inter-window communications in a loosely coupled manner is really important. 

A _Mediator_ is a behavioral design pattern that allows to unify communication of the application components. The Mediator pattern promotes the use of a single shared subject that handles (mediates) the communication with multiple objects. None of the components is aware of the others, but each of them knows about a single object - the mediator.

In Chapter 1 we've introduced an example of trader's desktop. Let's reuse the same example and refactor it with the Mediator object.  

The Pricing Panel on the left gets the data feed about the current prices of the IBM stock. When the user clicks on Bid or Ask button, the Pricing Panel just sends the event with the relevant trade information, e.g. a JSON-formatted string containing the stock symbol, price, buy or sell flag, date, etc.

[[FIG1-2]]
.Before the trader clicked on the Price Panel
image::fig_07_06.png[]

.After the trader clicked on the Price Panel
image::fig_07_07.png[]

[source,html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>An example of Mediator Design Pattern</title>
    <script data-main="app/config" src="bower_components/requirejs/require.js"></script>
</head>
<body>
<h1>mediator_require running!</h1>
<label for="priceInput">Bid price:</label>
<input type="text" id="priceInput" placeholder="bid price"/>
</body>
</html>
----


[source,javascript]
----
include::include/ch7_mediator.js[]
----
<1> A mediator maintains collection components. With `Mediator.register()` function we can store component in that collection. A `name` function parameter 

[source,javascript]
----
include::include/ch7_mediator_usage.js[]
----
<1> 
<2> With `Mediator.broadcast()` function a mediator object 
<3> 

[source,javascript]
----
include::include/ch7_pricepanel.js[]
----

[source,javascript]
----
include::include/ch7_orderpanel.js[]
----

[source,javascript]
----
include::include/ch7_mediator_usage.js[]
----
<1> 
<2> With `Mediator.broadcast()` function a mediator object 
<3> 

[source,javascript]
----
include::include/ch7_pricepanel.js[]
----

[source,javascript]
----
include::include/ch7_orderpanel.js[]
----

The introduction of the mediator increases the reusability of the components by decoupling them from each other. The Mediator pattern simplifies the maintenance of the system by centralizing navigational logic, and it reduces the variety of messages sent between objects in the system. Be aware that without proper design the Mediator object itself can become overly complex.

=== Summary

The size of your application tends to increase, and sooner or later you'll need to decide how to cut it into several loadable blocks of functionality. The sooner you start modularizing your application the better. 

In this chapter we've reviewed several options available for writing modular JavaScript using modern module formats. These formats have a number of advantages over using just the classical  Module Pattern. These advantages include avoiding creating global variables for each module and better support for static and dynamic dependency management.

Understanding various technologies and frameworks available in JavaScript, combined with the knowledge of different ways of linking modules and libraries is crucial for developers who want their JavaScript applications to be more responsive.
