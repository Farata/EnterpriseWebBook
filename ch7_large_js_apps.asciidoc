:toc:
:toclevels: 4
:icons: font
:imagesdir: ./images

== Large-Scale JavaScript Projects

Reducing the startup latency and implementing lazy loading of certain parts of the application are main reasons for modularizing Web applications. A good illustration of why you may want to consider cutting the code base of your Web application is a well designed Web application of the http://www.mbusa.com/[Mercedes Benz USA]. This Web application serves people who live in America and either own or consider purchasing cars from this prestigious European car manufacturer.

One of the option to purchase a vehicle is called European Delivery. An American resident can combine car purchase with  vacation. He or she would fly to Europe to the car factory, pick up the car there and then would be vacationing for two weeks driving your new vehicle in Europe. After the vacation your car would be shipped to your home town in the USA.  It's a really nice program, but would have added several thousand dollars to the price of the car.

From the application design code of view, we don't need to push include the code that support the European Delivery to each and every user's who decided to visit mbusa.com. If and only if the user will visit the menu Owners and will click on the European Delivery link, then the required code and resources has to be pushed to the user's computer or mobile device. The snapshot in <<FIG7-1>> was taken after clicking on this link with Chrome Developer tools panel open.

[[FIG7-1]]
.MB USA: Europian Delivery 
image::fig_07_01.png[image]

As you see, 1.9Mb worth of code and other resources have been downloaded as a result of this click. Should the application architects of the MB USA IT decided to load this code on the initial load of mbusa.com, the user would have to wait for another second or more, which would be a wrong design because only a tiny number of American driver would be interested in even looking at the European Delivery option. This is an example of modularization and lazy loading in action.

Our Save Sick Child application is not as big as Mercedes Benz site. But we'll use it to give you an example of how to build  modularized Web applications that won't bring the monolithic ten megabyte application to the client's machine, but will load the code on as needed basis. We'll also give an example of how to organize the data exchange between different programming modules in a loosely coupled fashion.

People consider your web application fast for one of two reasons: either it's actually fast or it gives an impression of being fast. Ideally, you should do your best to create an web application that is very responsive. No matter how slow your web application is, it should never feel like freezing.

This chapter is about modularization techniques that will quickly render the first page of your web application on the user's Browser while loading the rest of the application in the background or on demand. We will continue refactoring the Save Sick Child application to illustrate using modules.

There is no out-of-the box modularization scheme in JavaScript language. The upcoming ECMAScript 6 specification tends to resolve this with introduction a _module concept_ in the JavaScript language itself. But it's the future.

Of course, we can load each JavaScript file using `<script>` tag. But this approach slow and error prone. Developer has to manage dependencies and loading order manually. Moreover, each `<script>` tag directive translates into an additional HTTP call to the server. As the application gets larger the latency will growth accordingly, which is illustrated in the following code sample.
<<LISTING_SCRIPT_TAG,Here is an example>>.


[[LISTING_SCRIPT_TAG]]
.Tons of `<script>` tags leads to loosing control of the application dependencies
[source,html]
----
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8">
    
    <title>Save Sick Child | Home Page</title>
    <link rel="stylesheet" href="assets/css/styles.css">

    <script src="components/jquery.js></script>     <!-- <1> -->

    <script type="text/javascript" src="app/modules/utils/load-html-content.js"></script>
    <script type="text/javascript" src="app/modules/utils/show-hide-div.js"></script>
    <script type="text/javascript" src="app/modules/svg-pie-chart.js"></script>
    <script type="text/javascript" src="app/modules/donation.js"></script>
    <script type="text/javascript" src="app/modules/login.js"></script>
    <script type="text/javascript" src="app/modules/utils/new-content-loader.js"></script>
    <script type="text/javascript" src="app/modules/generic-module.js"></script>
    <script type="text/javascript" src="app/modules/module1.js"></script> <!-- <2> --> 
    <script type="text/javascript" src="app/modules/module2.js"></script>
    <script type="text/javascript" src="app/config.js"></script>
    <script type="text/javascript" src="app/main.js"></script> <!-- <3> -->

</head>
<body>
<!-- page body -->

</body>
</html>
----
<1> All modules depend on the code from Core jQuery library - loading it first.

<2> The application components may also have dependencies on other scripts. Those scripts need to be loaded before the component itself. The order of these script tags is very important.

<3> The main application script should be loaded after all dependencies.

We need a different approach to modularizing applications. Let's  start with using the Module pattern to leverage Immediately-Invoked Function Expressions (IIFE) as the first step to modularization. Next, we will introduce and compare two popular JavaScript solutions and modularization patterns - CommonJS and Asynchronous Module Definition (AMD), which are alternative approaches to implementing modularization. Both CommonJS and AMD are specifications and set of APIs. In this chapter we will use http://browserify.org/[Browserify] as CommonJS example, and http://requirejs.org/[RequireJS] as AMD example.

You'll see how the upcoming EcmaScript 6 specification suggests dealing with modules, and how you can start using ES6 module syntax today with the help of third-party tools like http://corner.squareup.com/2013/02/es6-module-transpiler.html[transpiler]. The ES6 module syntax can be compiled down to existing module solutions like CommonJS or AMD.

Finally, we're going to discuss such advanced topics as intermodule-communication and Dependency Injection in JavaScript.

The code of the Save Sick Child application will be refactored to implement module system based on RequireJS for lazy loading of the  application components.

****
.[underline]#Plan for chapter#
* [line-through]#History: the Module pattern, namespaces#
* CommonJS
* AMD ~70%
* [blue line-through]#https://github.com/umdjs/umd[UMD]#
* Advanced topics:
** https://gist.github.com/wycats/51c96e3adcdb3a68cbc3[ES6 modules] (http://wiki.ecmascript.org/doku.php?id=harmony:modules) and TypeScript modules
** Inter-Module communication, Mediator pattern, Pub/Sub/EventBus example
** _Dependency Injection_
* ExtJS style (sidebar example ???)
****

=== Modularization basics

//Those are raw notes of thoughts 
//Aren't Js Files Simply Modules Already?
//Modules are pieces of code that are focused on a specific set of functionality, written using a specific pattern to facilitate modular use of the code.
//There's several approaches one can use to create modular JS.
//We'll be focusing on code that can be consumed by a module loader.

=== The Paths To Modularization

==== Module Pattern

In general software engineering, the Module pattern was originally defined as a way to implement encapsulation of reusable code. In JavaScript, the Module pattern is used to emulate the concept of classes. We're able to include both public/private methods and variables inside a single object, thus hiding particular section of code from global scope. Such encapsulation lowers the likelihood of conflicting function names defined in different scripts, but used in the same application's scope.

Ultimately, it's just some code in an IIFE that creates a module object in the internal scope of a function and exposes that module to the global scope using various JavaScript syntax. Here are couple examples how Module Pattern could be implemented using IIFEs.

.Returning the value from a module 
[source,javascript]
----
include::include/ch7_iife_loginModule.js[]
----
// TBD callouts

.Piggiybacking on global object
[source,javascript]
----
include::include/ch7_iife_global_loginModule.js[]
----
// TBD callouts

.Application Namespace in global object
[source,javascript]
----
include::include/ch7_iife_namespace_loginModule.js[]
----

This approach doesn't scale well because when working with an application with a large number of modules, very soon you may find yourself adding lots of boilerplate checks of objects existence in the global scope for each new module. Also, you need to be very careful with managing namespaces. Because you are the one who put an object into the global scope, you need to think about how to avoid accidental names conflicts.

There is one huge disadvantage of using the Module pattern - we still need to deal with manual dependency management and manually arranging `<script>` tags in the HTML document.


==== CommonJS

// TDB

http://www.commonjs.org/[CommonJS] is a working group that works on design, prototyping and standardization of JavaScript APIs. They've attempted to develop standards for both modules and packages. The CommonJS module proposal specifies simple API for declaring modules, but mainly on the server-side.

http://browserify.org/[Browserify] takes all of your scripts and concatenates them itto one large file.

* require
* exports
* module

// provide the example
Each module is executed in its own scope.
How to make that code available if it's not in global scope?

`exports`
The exports variable is an object that has the implicit value of your module. When your module is requested, the code is executed and then exports is returned for you.

CommonJS pros:

* It's a simple API for writing and using modules.
* This modules organization pattern is widespread in server-side JavaScript, e.g. NodeJS.

CommonJS cons:

* The additional build step required. We will discuss this in <<Browserify>> section.
* The `require` method is synchronous, but module values may not be fully loaded during the execution.
* It's Suitable for loading +js+ files, but can't load other assets via CommonJS APIs.

[[Browserify]]
===== Browserify

http://browserify.org/
https://github.com/substack/node-browserify


==== Asynchronous Module Definition

AMD began as a draft specification for module format in CommonJS, but since the full consensus about its content was not reached, the further development of the module format moved to the https://github.com/amdjs[amdjs Github page].

The AMD module format itself is a proposal for defining modules where both the module and dependencies can be asynchronously loaded. 
The AMD API is based on a https://github.com/amdjs/amdjs-api/wiki/AMD[this specification]. The AMD API have the following main functions:

[[DEFINE_DESC]]
* `define` for facilitating module definition. A function takes two arguments:
** An optional array of modules IDs, which serve as this module's dependencies
** A callback function (often referred to as a _factory function_), which will be invoked when dependencies are loaded. This also can be a value to use directory as the module's value.
+

[[LISTING_define_func]]
.The example of a `define` function
[source,javascript]
----
define(
    module_id,          // <1>
    [dependencies],     // <2>
    function {}         // <3>
);
----
<1> This string literal is an optional parameter. It defines +module_id+ that will be used by AMD for loading this module.
<2> An optional array of dependencies' ids.
<3> The function for instantiating the module or object.
+

[[LISTING_define_modeule]]
.The Definition of the `wayToGive` module
[source,javascript]
----
include::include/ch7_define_wayToGive.js[]
----
<1> In this example, we are not providing the optional +module_id+. The file name without the `.js` extension will be used as +module_id+. Our module has one dependency on the module called +newContentLoader+. The module instance will be passed in the factory method as variable +contentLoader+. 
<2> We can start use dependency object immediately. AMD loader have taken care of loading and instantiation of this dependency.
<3> Module defines and returns constructor function for new objects.

[[REQUIRE_DESC]]
* `require` function takes two arguments
** An array of module IDs to load. Module ID is a string literal.
** A callback to be executed once those modules are available. The modules loaded by ID are passed into the callback in their relative positions. <<LISTING_Require_func,Here is example>> of `require` function usage.
+

[[LISTING_require_func]]
.Example of `require` function usage
[source,javascript]
----
require(["main"], function() {
    console.log("module main is loaded");
}); // <1>
----
<1> Loads module with id +main+ and executes the anonymous function after module and all its dependencies are loaded.

`exports` 
Distinctions from CommonJS

//TBD

===== AMD Pros and Cons

AMD pros:

* It's a very simple API that has only two functions - `require` and `define`. 

* A wide variety of loaders is available. You'll find more coverage on loaders in the <<REQUIREJS, RequireJS section>>.

* Plugins offer an immense amount of flexibility

* Easy To Debug
+

Consider following error messages that JavaScript interpretor can throw:
+

_There was an error in /modules/loginModule.js on line 42_
+

*vs*
+

_There was an error in /built-app.js on line 1984._
+

When your application if modularized you can identify the error easier.

* Performance: module are loaded only when required hence the initial portion of the application's code become smaller.
+

You may want to load a module on demand when the user clicks the button or selects a menu item. In the following example, the module can be in one of three states: 

* not loaded (`module === null`)
* loading in progress (`module === 'loading'`)
* fully loaded (`module !== null`).
+

.Loading +widget1+ module on demand
[source,javascript]
----
var module;
var buttonClickHandler = function(event) {
  if (module === "loading") {       // <1>
    return;
  }
  if (module !== null) {        // <2>
    module.render();
  } else {
    module = "loading";         // <3>
    require(["modules/widget1"], function(moduleObject) { // <4>
      module = new moduleObject();      
      module.render();
    });
  }
};
----
<1> Checking if a module loading in progress.
<2> We don't want to load the module each time. If module was loaded just call method to render widget on the page.
<3> Setting the module into intermediate state until it's fully loaded. 
<4> Once the module is loaded, instantiate the new widget object and render it in the page.

AMD Cons:

* The dependency array can get rather large for complex modules (Example TBD).
* Easy to get a mismatch between dependency array and callback arguments (Example TBD).

[[REQUIREJS]]
===== RequireJS

After discussion of theory and basics of AMD it is time to see how modularization can work in the real world. In this section we'll  introduce the AMD-complaint module loader http://requirejs.org/[RequireJS]. 
RequireJS (include info about build with `r.js`)

// vik

****
http://github.com/cujojs/curl[*curl.js*] is another AMD-compliant asynchronous loader. 

****

// /vik

You can download require.js from its github repository or use a package manager like <<what_is_bower,Bower>>.

[[what_is_bower]]
.What is *Bower*?
****
https://github.com/bower/bower[Bower] is a package manager for the web projects. Bower was developed in Twitter and was donated to open-source community. Bower is a utility and a community driven repository of libraries and frameworks for front-end development. Bower's idea is very similar to NPM. But if NPM is more suitable for the server-side projects, on the contrary, Bower was designed and implemented to handle  dependencies for web projects.

Bower will take care of transitive (dependency of dependency) dependencies and download all required library components. Each Bower package has +bower.json+ file. This file contains a package metadata. Using that metadata, Bower can manage the package's transitive dependencies. Also +bower.json+ can might contain information about package repository, readme file, license and etc. You can find +bower.json+ in the root directory of package. For example, the path +components/requirejs/bower.json+ is a path for for RequireJS metadata file.

As other open-source tools that we use in this book, Bower could be installed via NPM. 

[source,bash]
----
npm install -g bower    # <1>
----
<1> NPM installs Bower globally in your systems.

Next you can start using Bower. For example, here is a Bower's command to install RequireJS.

[source,bash]
----
bower install requirejs --save # <1>
----
<1> Bower installs RequireJS into +components/requirejs+ directory and saves information about dependency in +bower.json+ configuration file.

Bower, as well as NPM, simplifies delivery of dependencies into target platform. Which means, you not necessary need to store dependencies of your application next to a application files under source control. Your application could have its own +bower.json+ with list of the dependencies. At this point, Bower can install all required application dependencies with one command - `bower install`. And you can find all your dependency files in +components+ directory.

Here is how +bower.json+ looks like for Save Sick Child application.

[source,javascript]
----
{
  "name": "ch7_dynamic_modules",
  "description": "Chapter 7: Save Sick Child, Dynamic Modules app",
  "dependencies": {
    "requirejs": "~2.1.5",
    "jquery": ">= 1.8.0",
    "qunit": "~1.11.0",
    "modernizr": "~2.6.2",
    "requirejs-google-maps": "latest"
  }
}
----
<1> Application dependencies are specified in corresponding +dependencies+ section.

[[application_components]]
.Directory structure of application's components
image::fig_07_04.png[align="center"]

Also, there is a http://sindresorhus.com/bower-components/[Bower search tool] to find desired component in repository.

****

.Adding RequireJS to the web page
[source,html]
----
<!DOCTYPE html>
<head>
    <!-- content omitted -->
</head>
<body>
<!-- page body -->

<script src="components/requirejs/require.js" 
        data-main="app/config"></script> <!-- <1> -->

</body>
</html>
----
[[data_main_attrib]]
<1> The `data-main` attribute is needed for require.js. It specifies that the framework should load `app/config.js` after +require.js+ loads. The `app/config.js` is the entry point of your application.

// vik

.Inside config.js
RequiredJS will need a configuration. Configuration object helps RequireJS to understand that modules and dependencies will managed the framework.

[source,javascript]
----
include::include/ch7_require_config.js[]
----
<1> http://requirejs.org/docs/api.html#config[Documentation] has comprehensive overview of configuration options. We don't want to duplicate it here.

<2> The `path` configuration option defines the mapping for module names and its paths. The paths is used for module names shouldn't contain file extension.

<3> After configure module paths we're loading 'main' module. All our application flow is defined there.

// /vik


.r.js - RequireJS Optimizer
****
RequireJS comes with the optimization tool called http://requirejs.org/docs/optimization.html[_r.js_], which is a utility that does optimization of modules. 

// vik

As you learned earlier in this chapter, we specified the dependencies as array of string literals that are passed to top-level <<REQUIRE_DESC,require>> and <<DEFINE_DESC,define>> calls. The optimizer will combine modules and its dependencies into single file using that dependencies information.

// /vik

Furthermore, r.js integrates with other optimization tools like `UglifyJS` and `Closure Compiler` to minify content of script files.

*TODO*: _Make introduction of Grunt Tools in this chapter not next chapter._ 

Let's configure our Grunt project to enable optimization task.

.Add RequireJS dependency to package.json
[source,bash]
----
> npm install grunt-contrib-requirejs grunt-contrib-concat grunt-contrib-clean grunt-contrib-uglify --saveDev # <1>
----
<1> Install requirejs, clean, concat and uglify grunt tasks packages and save them as development dependency in package.json.

<<rjs_gruntfile_list,Following listing>> describes how to setup RequireJS optimizer and related optimization tasks for Grunt.

[[rjs_gruntfile_list]]
[source,javascript]
----
include::include/ch7_rjs_Gruntfile.js[]
----

<1> The +clean+ task cleans output directory. In the `files` section of task config we specify what folder should be cleaned.
<2> The +requirejs+ task. The configuration properties of +requrejs+ task are self-explanatory. +mainConfigFile+ points at the same file that <<data_main_attrib,`data-main` attribute>> of RequireJS script tag. +out+ parameter specifies output directory where optimized script will be created.
<3> The +concat+ task combines/concatenates together optimized modules code and RequireJS loader code.
<4> The +uglify+ task minifies provided files using http://lisperator.net/uglifyjs/[UglifyJS] - a compressor/minifier tool. UglifyJS produces significantly smaller version of original script by reducing Abstract Source Tree (AST) and mangling local variable to single-letters.
<5> Loading plugins that provide necessary tasks.
<6> The default task to execute all tasks in order.

Monitor the network traffic of the Save Sick Child application built with RequireJS in Chrome Developer Tools, and you'll see  many HTTP requests that load modules asynchronously. As you can see from the <<unoptim_require_fig,from following screenshot>>, 12 out of 14 requests that browser sends are for loading all required modules.

[[unoptim_require_fig]]
.Unoptimized version of Save Sick Child Application
image::fig_07_02.png[]

The next <<optim_with_rjs_fig,screenshot>> shows the loading of Save Sick Child application optimized with RequireJS optimizer. As you can see, we managed to pack all our modules, its dependencies and loader's code under one single file. And considerably decreased number of server-side calls.  

[[optim_with_rjs_fig]]
.Loading of optimized version of Save Sick Child 
image::fig_07_03.png[]

You can find more information about different optimization topics on the RequireJS documentation site under http://requirejs.org/docs/optimization.html[``Optimization''] section.

****


==== Universal Module Definition (UMD)

Universal Module Definition (UMD) is the series of patterns / code snippets that provide compatibility boilerplate to make modules environment-independent. Those patterns can be used support multiple modules formats. 

Here is an example of module definition using UMD notation. A module can register itself using the `define()` method if it detects the AMD loader or registers itself in browser globals.


[source,javascript]
----
include::include/ch7_umd_amd_globals.js[]
----
<1> Checking if the AMD loader is available. If it is, proceed with defining the module according AMD specification.

<2> If the AMD loader isn't present, use the factory method to instantiate object and attach it to the global scope (i.e. `window` object in case of executing this code in a Web browser).

<3> Passing the top-level context and defining providing a implementation of a factory function.

It's worth mentioning that UMD is not a specification or a standard. You need to care about UMD in case when your modules shall run in more than one type of environment (e.g. a browser and on the server side engine running NodeJS). In most cases, it makes a lot of sense to use a single module format.
You can find more information about UMD and commented code snippets for different situations in https://github.com/umdjs/umd[the UMD project repository].

==== ECMAScript 6 Modules

// This section under active development

The ECMAScript 6 (ES6) specification is an evolving draft outlining changes and features for the next version of JavaScript. This specification will be finalized soon, but before that happens the browsers' support for anything defined in ES6 will be experimental at best and cannot be relied upon for Web applications that must run in multiple browsers. One of the most important features of the upcoming ES6 specification is the _module syntax_. Here is an example of how it suggests to define and use a module:

.Login module definition
[source,javascript]
----
function Login(userNameValue, userPasswordValue) {
    console.log("login implementation omitted");
};
export = Login;
----

And this is how can be used:

.Main application module
[source,javascript]
----
import "login" as Login;
var result = Login("admin", "password");
----

.ES6 module transpilers
****
http://corner.squareup.com/2013/02/es6-module-transpiler.html[ES6 transpiler] developed by http://squareup.com/[Square] Engineers.

TDB: TypeSctript module feature
****

=== Advanced Modularization

=== Summary

The size of your application tends to increase, and sooner or later you'll need to decide how to cut it into several loadable blocks of functionality. The sooner you start planning for modularizing your application the better. 

In this chapter we've reviewed several options available for writing modular JavaScript using modern module formats. These formats have a number of advantages over using the (classical) module pattern alone including: avoiding a need for developers to create global variables for each module and better support for static and dynamic dependency management.

Understanding what technologies and frameworks available in JavaScript, combined with the knowledge of different ways of linking modules and libraries to your main application is crucial for the creation of responsive JavaScript applications.
