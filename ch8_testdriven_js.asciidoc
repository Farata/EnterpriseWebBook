== Test-Driven Development with JavaScript

// [quote, @bphogan, http://twitter.com/bphogan/status/194856922208407552]

To shorten the development cycle of your Web application you need to start testing it on the early stages of the project. It seems obvious, but many enterprise IT organizations haven't adopted the agile testing methodologies, which costs them dearly. JavaScript is dynamically typed interpreted language, which means that there is no compiler to help to identifying errors as it's done in compiled languages like Java. This means that for
JavaScript Web applications a lot more time should be allocated for testing.

// <vik>
Static code analysis and code quality tools such as http://esprima.org/[Esprima] and http://www.jshint.com/[JSHint] can help to reduce amount of syntax error and improve your JavaScript quality.

//</vik>

To switch to a test-driven development, start with accepting the notion of embedding testing into your development process rather than scheduling testing after the development cycle is complete.

In this chapter we'll give you a brief overview of selected test frameworks for JavaScript: http://qunitjs.com/[Qunit] and http://pivotal.github.com/jasmine/[Jasmine]. We will cover the basic testing techniques such as "Test-driver development" and "Test First". You'll learn how to automate the testing process in multiple browsers with http://vojtajina.github.com/testacular/[Testacular] or by running tests in so called _headless_ mode with http://phantomjs.org/[PhantomJS]. You'll learn how to mock and stub selected artifacts of the environment (such as `XMLHTTPRequiest` object or timer) with http://sinonjs.org/[Sinon.js] and how to unit test the DOM manipulation code.

The second part of this chapter is dedicated to setting up a new Save Sick Child project in the IDE with selected test frameworks.

=== Why to test ?

// <vik>
Software has bugs. We want to minimize its numbers and make changes to be safe.
We need constantly test the code to catch regression errors, so we can add new features without breaking existing ones. Covered with tests code easy to refactor. Tests help to prove correctness of out code. Well tested code leads to the better design.

// TBD

=== Testing Basics

The basic types of testing are:

- Unit
- Integration
- Functional
- Load

The sections that follow examine the differences between these testing strategies and list the tools that will help you in automation of the testing process.

==== Unit Testing

Unit testing is performed by a developer and is targeted at small pieces of code to ensure, for example, that if you call a function with particular arguments, it will return the expected result.

==== Integration Testing

Integration testing is a process in which a developer combines several unit tests to ensure that they work properly with each other.
We use the term integration tests to refer to the tests that check how some of our code works with code from outside the team that we can't change. It might be a public framework or a library from another team within our enterprise. The distinction is that integration tests make sure that any abstractions we build over third-party code work as we expect.
Both unit and integration tests have to be written by application developers.

==== Functional Testing

Functional testing (or acceptance testing) is aimed at finding out whether the application properly implements business logic. For example, if the user clicks on a row in the customer data grid, the program should display a form view with specific details about the selected customer. In functional testing business users should define what has to be tested, unlike unit or integration testing where tests are created by software developers.
Functional tests can be performed manually, in which a real person clicks through each and every view of the web application, confirming that it operates properly or reporting discrepancies with the functional specifications.

//TBD
// TODO Is Casper.js good example to demonstrate functional testing of app?
// http://casperjs.org/quickstart.html
// ... or Zombie.js http://zombie.labnotes.org/

==== Load Testing

Load testing is a process that can help answer to following questions:
How many concurrent users can work with your application? But without bringing your server to its knees? Even if the server is capable of serving a thousand users, will performance suffer? If yes, how bad is it going to be?

//TBD

==== Test Driven Development

Test-Driven Development (TDD) turns "classic" software development on its head. We write our tests even before we write the production code. Instead of just using testing to verify our work after it's done, TDD turns testing into a design activity. We use the tests to clarify our ideas about what we want the code to do.
Here is fundamental mantra of TDD:

- Write a test and make it fail.
- Make the test pass.
- Refactor.
- Repeat.

This technique also referred as "Red-Green-Refactoring" because IDE's and test runners use red color to indicate failed test and green color to indicate passed tests.

Here the example that can clarify what we just said earlier. When you are about to start programming a class with some business logic, ask yourself, "How can I ensure that this function works fine?" After you know the answer, write a test JavaScript class that calls this function to assert that the business logic gives the expected result. And first time your test will fail because there is no production code yet. Only after the test is written, start program the business logic. You should write a simplest possible piece of code to make test pass. Don't try to find generic solution at this step. For example, if you want to test calculator that needs to return `4` as result of `2+2` write production code what simply returns `4`. Don't worry about performance or optimization on this step. Just make the test pass. Once you made it, you can refator your production code. Now you might want to introduce more optimal algorithm for for solving your production problem without worrying to break contract with other units of your application. Failed unit test will indicate that your change caused regression. Actually, it's good thing. TDD allows receive feedback from your code almost immediately.
It's better to find that something is broken in development rather than in production.

// TODO - develop the idea of receiving feedback from code. http://vimeo.com/36579366

[NOTE]
===============================
And learn by heart The Golden Rule Of TDD:
____
Never write new functionality without a failing test
____
===============================

Say we want to test validation logic in donation entry form.

//TODO - here should be code example with

In addition to business logic, web applications should be tested for proper rendering of UI components, changing view states, dispatching, and handling events.

==== «Automate All The Things»!

We must automate testing as much as we can to reduce the costs of building, deploying, and modifying versions of the system. In this chapter we're going to introduce build automation tool for JavaScript project called http://gruntjs.com/[Grunt]. With Grunt help we'll automate process of running tests once code is changes. Tests should help us to provide feedback about quality of our code. We will show how setup Grunt to watch of your code changes and run tests right after you saved the file.

TBD

//</vik>

=== Save Sick Children With TDD

TBD