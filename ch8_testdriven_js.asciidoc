:toclevels: 3
:imagesdir: ./images

== Test-Driven Development with JavaScript

// [quote, @bphogan, http://twitter.com/bphogan/status/194856922208407552]

To shorten the development cycle of your Web application you need to start testing it on the early stages of the project. It seems obvious, but many enterprise IT organizations haven't adopted the agile testing methodologies, which costs them dearly. JavaScript is dynamically typed interpreted language, which means that there is no compiler to help to identifying errors as it's done in compiled languages like Java. This means that a lot more time should be allocated for testing for JavaScript Web applications. Moreover, a programmer who didn't introduce unit testing techniques into his daily routine can't be 100% sure that his code is working properly.

The static code analysis and code quality tools such as http://esprima.org/[Esprima] and http://www.jshint.com/[JSHint] will help in reducing the number of syntax errors and improve the quality of your code. Later in this chapter we will demonstrate how to setup +JSHint+ for your JavaScript project and check your code for the syntax errors automatically. 

To switch to a test-driven development mode, make testing a part of your development process in its early stages rather than scheduling testing after the development cycle is complete.

Introduction of test-driven development may substantially improve you code quality. It is very important to receive the feedback about your code on a regular basis. That's why unit tests must be automated. Ideally, the tests should run as soon as you've changed the code. In this chapter we are going to introduce Grunt - the task runner tool - that can help you with automation of repetitive operations like running unit tests when the code changes. 

There are many testing frameworks in JavaScript world, and in this chapter we'll give you a brief overview of two of them: http://qunitjs.com/[Qunit] and http://pivotal.github.com/jasmine/[Jasmine]. The main goal of each framework to is to test small pieces of code a.k.a. _units_.  We will also show how to abstract your JavaScript project lifecycle from any specific frameworks or libraries using Grunt tool.

We will go through the basic testing techniques such as "Test-driver development" and "Test First". You'll learn how to automate the testing process in multiple browsers with http://karma-runner.github.io/[Karma Runner] or by running tests in so called _headless_ mode with http://phantomjs.org/[PhantomJS]. You'll learn how to mock and stub selected artifacts of the environment (such as `XMLHTTPRequiest` object or timer) with http://sinonjs.org/[Sinon.js] and how to unit test the DOM manipulation code.

The second part of this chapter is dedicated to setting up a new Save Sick Child project in the IDE with selected test frameworks.

=== Why Testing

Any software has bugs. But in interpreted languages like JavaScript you don't have help of compilers that could have pointed you at the potential issues on early stages of development. You need to continue testing the code over and over again to catch regression errors, to be able to add new features without breaking the existing ones. The code covered with tests is easy to refactor. Tests help to prove correctness of your code. A well tested code leads to the better overall design of your programs.

=== Testing Basics

In this chapter we are going to discuss the following types of testing (we don't cover QA and UAT in this book):

- Unit tests
- Integration tests
- Functional tests
- Load (a.k.a. stress) tests

Let's go over the strategies, approaches, and tools that will help you in automation of each of the above tests.

==== Unit Testing

The _unit test_ is a piece of code that invokes the method or class being tested. It _asserts_ some assumptions about the application logic and behavior of the  method or class. You'll be writing unit tests using a unit-testing framework. The test should run fast, be automated and readable. For example you can test that if a function is called with a particular arguments, it should return an expected result.
We will take a closer look on unit testing terminology and vocabulary in a <<TDD>> section.

==== Integration Testing

Integration testing is a phase when already tested units are combined into a module to test the interfaces between them. You may want to test the integration of your code with the code written by other developers, e.g. some framework. Integration tests ensures that any abstractions we build over the third-party code work as expected. Both unit and integration tests are written by application developers. 

==== Functional Testing

Functional testing (or acceptance testing) is aimed at finding out whether the application properly implements business logic. For example, if the user clicks on a row in the customer data grid, the program should display a form view with specific details about the selected customer. In functional testing business users should define what has to be tested, unlike unit or integration testing where tests are created by software developers. Functional tests can be performed manually, in which a real person clicks through each and every view of the web application, confirming that it operates properly or reporting discrepancies with the functional specifications.

//TBD
// TODO Is Casper.js good example to demonstrate functional testing of app?
// http://casperjs.org/quickstart.html
// ... or Zombie.js http://zombie.labnotes.org/

==== Load Testing

Load testing is a process that can help in answering the following questions:

* How many concurrent users can work with your application without bringing your server to its knees? 
* Even if your server is capable of serving a thousand users, is your application performance in a compliance with the service level agreement (SLA), if any? 

//TBD

[[TDD]]
=== Test Driven Development

The methodology known as Test-Driven Development (TDD) substantially changes the way a "classic" software development is done. This methodology wants you to write tests _even before_ writing the application code. Instead of just using testing to verify our work _after it's done_, TDD moves the testing into the earlier application design phase. You should use the tests to clarify your ideas about what you are about to program. Here is fundamental mantra of TDD:

- Write a test and make it fail.
- Make the test pass.
- Refactor.
- Repeat.

This technique also referred as "Red-Green-Refactoring" because IDE's and test runners use red color to indicate failed test and green color to indicate passed tests.

When you are about to start programming a class with some business logic, ask yourself, "How can I ensure that this function works fine?" After you know the answer, write a test JavaScript class that calls this function _to assert_ that the business logic gives the expected result. 

An assertion is a true-false statement that represents what a programmer assumes about program state, e.g.  *customerID >0* is an assertion. 

According to Martin Fauler, an assertion is a sections of code work only if certain conditions are true (M.Fauler Refactoring - Improving the Design of Existing Code, 2002 p.212). An assertion is a conditional statement that is assumed to be always true. Failure of an assertion results in test failure. 

Run your test, and it  will immediately fail because no application code is written yet! Only after the test is written, start programming the business logic of your application 

You should write a simplest possible piece of code to make the test pass. Don't try to find a generic solution at this step. For example, if you want to test calculator that needs to return `4` as result of `2+2` write the code what simply returns `4`. Don't worry about performance or optimization on this step. Just make the test pass. Once you made it, you can refactor your application code. Now you might want to introduce a real algorithm for implementing the application logic without worrying about breaking the  contract with other components of your application. 

A failed unit test indicates that your code change introduced regression, which is a new bug in a previously worked software. Automated testing and well-written test cases can reduce the likelihood of a regression in your code.

TDD allows to receive feedback from your code almost immediately. It's better to find that something is broken during development rather than in the application deployed in production.

// TODO - develop the idea of receiving feedback from code. http://vimeo.com/36579366

[NOTE]
===============================
And learn by heart The Golden Rule Of TDD:
____
Never write new functionality without a failing test
____
===============================

Say, you want to test validation logic in Donation entry form.

//TODO - here should be code example with

In addition to business logic, web applications should be tested for proper rendering of UI components, changing view states, dispatching, and handling events.

// <vik>
Regardless of that testing framework are you using, your tests will follow same basic pattern. First of all, you need to setup up the test environment. After that, you run a production code and check that your production code did that it supposed to. At the very end you need to clean up after yourself.
This pattern for authoring the unit tests has name _Arrange-Act-Assert_ (AAA footnote:[ http://integralpath.blogs.com/thinkingoutloud/2005/09/principles_of_t.html[Principles for Test-Driven Development] ]).

In _Arrange_ phase you set up the unit under the test. For example, create a DOM element that your production code manipulates.

In _Act_ phase you exercise the unit under test and capturing any resulting state. Here you executing your production code in unit test context.

In the _Assert_ phase you verify the behavior through assertions.

There is one more phase - _Reset_. In this phase, if needed, you return environment to the initial state. For example, erase the DOM elements created in _Arrange_ phase.

Later in this chapter, we will show how different frameworks implements _AAAR_ pattern.

// </vik>

==== Automate Everything

You should automate testing as much as you can to reduce the costs of building, deploying, and maintaining your application. 

Now lets start building the foundation for our refactored application. We are going to use the tasks running framework for the JavaScript project called http://gruntjs.com/[Grunt]. With Grunt's help we'll automate process of running tests once the code changes. The tests should help in assessing the quality of our code. You'll learn how to setup Grunt to watch your code changes and run tests right after you modified the code and saved the changes. 

With the Grunt tool you can have a script to run all your tests. In you came from the Java world, you know about Apache Ant, a general-purpose command-line tool for drive processes described in build files as targets. Grunt also running the tasks described in. There is a wide range of tasks available today - starting with running automated unit tests and ending with JavaScript code minification. Grunt provides a separate layer of abstraction where you can define tasks in special DSL (domain-specific language) in Gruntfile and Grunt will execute it.

===== The Simplest Grunt File

You can follow http://gruntjs.com/getting-started[instruction from official website] to install Grunt on your machine.

Let's start with the simplest Grunt project setup. The following two files must be present in the project directory:

* `package.json`: This file is used by npm (https://npmjs.org/[Node Package Manager]) to store metadata for projects. You will list Grunt and its plugins your project needs as devDependencies in this file.
* `Gruntfile`: This file is named `Gruntfile.js` or `Gruntfile.coffee` and is used to configure or define the tasks and load Grunt plugins.

.The simplest possible Gruntfile
[source,javascript]
----------------------------------------------------------------------
module.exports = function (grunt) {
    'use strict';

    grunt.registerTask('hello', 'say hello', function(){    // <1>
        grunt.log.writeln("Hello from grunt");              // <2>
    });

    grunt.registerTask('default', 'hello');                 // <3>              
};
----------------------------------------------------------------------
// <vik>
<1> Register the new task named `hello`.
<2> Print the greeting text using http://gruntjs.com/api/grunt.log[grunt's log API]
<3> With `grunt.registerTask` we define a default task to run when Grunt is called without any parameter. 

Let's run this `hello` task with the command `grunt --gruntfile Grunt_simple.js hello`. 
Each task can be called separately from the command line by passing task's name as a command line parameter: For example `grunt hello` would only execute the listed above hello task.

[source,bash]
----------------------------------------------------------------------
Running "hello" task
Hello from grunt

Done, without errors.
----------------------------------------------------------------------

==== Test-driven development with QUnit

// <vik>
We will start our journey to JavaScript testing frameworks with http://qunitjs.com/[QUnit]. QUnit was originally developed by http://ejohn.org/about/[John Resig] as part of jQuery. QUnit now runs completely standalone and doesn't require jQuery dependency. While heavily used by the jQuery Project for testing jQuery, jQuery UI and jQuery Mobile, it can be used to test any generic JavaScript code.

// </vik>

===== Setup Grunt with Qunit

WARNING: Section is in active development

// <vik>
In this section of the chapter we're going learn how to automatically run the Qunit tests using Grunt.
Let's setup our project by adding the Qunit and tests file. We will start with downloading the latest version from http://qunitjs.com/[official web site]. We need to get only two files - `qunit-*.js` and `qunit-*.css`.

.A download section on QUnit website
image::fig_08_04.png[]

.QUnit framework in our project 
image::fig_08_05.png[]

.Our first QUnit test
[sources,javascript]
----
'use strict';
test("my first qunit test", function () {
    ok(2 + 2 === 4, "Passed!");
});
----

One more thing that we need for out test setup is a test runner. 

.A test runner
[source,html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>QUnit Example</title>
    <link rel="stylesheet" href="lib/qunit-1.11/qunit.css"> 
    <script src="lib/qunit-1.11/qunit.js"></script>     <!-- <1> -->
    <script type="text/javascript" src="../app/js/libs/jquery-1.9.0.min.js"></script> <!-- <2> -->
    <script src="test/tests.js"></script>               <!-- <3> -->
</head>
<body>
<div id="qunit"></div>
</body>
</html>
----

<1> A test runner is a html file contains links to QUnit framework JavaScript file.
<2> In this chapter we will continue to work on jQuery-based version of the "Save Sick Child" application. Out production depends on jQuery and we need to include jQuery in the test runner.
<3> Test files are included as well.

To run all our tests we just need to open the `qunit-runner.html` in browser.

.A test run results in browser
image::fig_08_06.png[]

.Gruntfile with qunit runner
[source,javascript]
----
module.exports = function (grunt) {
    "use strict";
    grunt.initConfig({
        qunit: {
            all: ["test/qunit-runner.html"]
        }
    });
    grunt.registerTask("test", "qunit");
    grunt.loadNpmTasks("grunt-contrib-qunit");
};
----

TODO:

Test methods:
         module(name, {[setup][ ,teardown]})
         test(name, callback)
         expect(numberOfAssertions)
         stop(increment)
         start(decrement)
Test assertions:
         ok(value, [message])
         equal(actual, expected, [message])
         notEqual(actual, expected, [message])
         deepEqual(actual, expected, [message])
         notDeepEqual(actual, expected, [message])
         strictEqual(actual, expected, [message])
         notStrictEqual(actual, expected, [message])
         throws(block, [expected], [message])

// <vik>

==== Behavior-Driven Development With Jasmine

The idea behind _behavior-driven development_ (BDD) is to use the "natural language" constructs to describe what you think your code should be doing, or more specifically, what your functions should be returning.

Similarly to unit tests, with BDD you write short specifications that test one thing at the time. Specifications should be sentences. For example, "Calculator adds two positive numbers". It will help you easy identify the failed test by simply reading this sentence in test results report. Now we'll demonstrate this concept using Jasmine, the BDD frameworks for JavaScript. Jasmine provides very nice way to group, execute, and report JavaScript unit tests. 

// TBD

===== Setup Grunt with Jasmine

You've learned already how to use Grunt tool to automate boilerplate tasks. Next in this section we're going to show how you can execute a Jasmine specification with Grunt. We'll cover the Jasmine basic in the next section, but for now think of Jasmine as a piece of code that should be executed by Grunt.

Let's start by downloading latest version of Jasmine from https://github.com/pivotal/jasmine/downloads[official github repository]. Unzip the archive. Content of unzipped folder will be looking similar to screenshot <<FIG-1>>.

.Jasmine Distribution
[[FIG-1]]
image::fig_08_01.png["Jasmine distribution"]

Jasmine comes with example spec (+spec+ folder) and html test runner - +SpecRunner.html+. Let's open +SpecRunner.html+ in browser <<FIG-2>>. 

.Running Jasmine Specs in a Browser
[[FIG-2]]
image::fig_08_02.png["SpectRunner.html"]

+SpecRunner.html+ file is very similar to the qunit html runner. You can run specs by opening the runner file in browser.  

[source, html]
----------------------------------------------------------------------
include::include/SpecRunner.html[]
----------------------------------------------------------------------

<1> Required Jasmine framework library
<2> Include source files
<3> Include specs code
<4> Initialize Jasmine and run all specifications when the page is loaded

Now let's update our Grunfile to run the same sample specifications with the headless browser. For that we need to copy content of +src+ folder of your Jasmine distribution into the `app/js` folder of our project, and then copy the content of the `spec` folder into the `test/spec` folder of our project. Also create a folder `test/lib/jasmine` and copy there content of Jasmine distribution `lib` folder. <<FIG-3>>

.Jasmine Specifications in Our Project
[[FIG-3]]
image::fig_08_03.png[]

Now we need to edit the +Gruntfile.js+ to activate Jasmine support.

.+Gruntfile_jasmine.js+ with Jasmine running support 
[source,javascript]
----------------------------------------------------------------------
module.exports = function (grunt) {
    'use strict';

    grunt.initConfig({
        jasmine: {  // <1>
            src: ['app/js/Player.js', 'app/js/Song.js'], // <2> 
            options: {
                specs: 'test/spec/PlayerSpec.js',   // <3>
                helpers: 'test/spec/SpecHelper.js'  // <4>
            }
        }
    });

    // Alias the `test` task
    grunt.registerTask('test', 'jasmine');
    // loading jasmine grunt module
    grunt.loadNpmTasks('grunt-contrib-jasmine');
};
----------------------------------------------------------------------

<1> Configuring Jasmine task
<2> Specifying the location of the source files
<3> Location of Jasmine specs
<4> Location of Jasmine helpers (will be covered later in this chapter)

To execute tests, run the command `grunt --gruntfile Gruntfile_jasmine.js jasmine`, and you should see something like this:

[source,bash]
----
Running "jasmine:src" (jasmine) task
Testing jasmine specs via phantom
.....
5 specs in 0.003s.
>> 0 failures

Done, without errors.
----


In this example, Grunt successfully executed the tests with PhantomJS of all five specifications defined in +PlayerSpec.js+. 

.What is PhantomJS?
****
PhantomJS is a headless WebKit-based rendering engine with JavaScript API.  Think of PhantomJS as a browser that doesn't have any graphical user interface. PhantomJS can execute HTML, CSS, JavaScript code. Because PhantomJS is not required to render GUI, it can be used in display-less environments (e.g.  Continuous Integration server) to run tests. In our case, Grunt automatically spawns PhantomJS instance, executes the code of our tests, reads the execution results using PhantomJS API, and prints them out in the console.
****

// <vik>
.What is Continuous Integration
****
TBD
****

In next section you will learn how write your own specifications.

===== Jasmine Basics

After we've set up the tools for running the tests let's start developing tests and learn the Jasmine framework constructs. Every specification file has a set of _suites_ defined in the `describe` function. Suites help logically organize the code of test specifications. 

.ExampleSpec.js
[source,javascript]
----
describe("My function under test should", function () {     // <1>
    it("return on", function () {                           // <2>
        // place specification code here
        //
    });
    describe("another suite", function () {                   // <3>
        it("spec1", function () {

        });
    });
    it("my another spec", function () {                    // <4>
        var truth = true;
        expect(truth).toBeTruthy();
    });
    it("2+2 = 4", function () {
        expect(2 + 2).toEqual(4);                       // <5>
    });
});
----

<1> The function `describe` accepts two parameters - the name of the test suite, and the callback function. The function is a block of code that implements the suite. If for some reasons you would like to skip suite from execution you can just use method `xdescribe` and whole suite will excluded until you rename it back to `describe`.

<2> The function `it` also accepts similar two parameters - the name of the test specification, and the function that implements this specification. Like in case with suites, Jasmine has paired `xit` method to exclude specification from execution.

<3> Each suite can have any number of nested suites.

<4> Each suite can have any number of specifications.

<5> The code checks to see if `2+2` equals `4`. We used the function toEqual(), which is a _matcher_.Define expectations with the function `expect`, which takes a value, called the actual. It is chained with a Matcher function, which takes the expected value (in our case it's 4) and checks to see if it satisfies some criterion in the matcher. Various flavors of matchers are shipped with Jasmine framework, and we're going to review a couple the frequently used matchers functions.

* Equality
+

Function `toEqual()` checks if two things are equal.

* True or False?
+

Functions `toBeTruthy` and `toBeFalsy` checks if something is true or false respectively.

* Identity
+

Function `toBe()` checks if two things are _the same object_.

* Nullness
+

Function `toBeNull` checks if something is +null+.

* Is Element Present
+

Function `toContain()` check if an actual value is an element of array.
+

[source, javascript]
----
expect(["James Bond", "Austin Powers", "Jack Reacher", "Duck"]).toContain("Duck");
----

* Negate Other Matchers
+

This function is used to reverse matchers to make sure that they aren't +true+. To do that, simply prefix things with `.not`:
+

[source, javascript]
----
expect(["James Bond", "Austin Powers", "Jack Reacher"]).not.toContain("Duck");
----

Above we've listed only some of existing matchers. You can find the complete documentation with code examples at http://pivotal.github.io/jasmine/#section-Matchers[official Jasmine website] and at https://github.com/pivotal/jasmine/wiki/Matchers[wiki].

===== Specification Setup

TBD

// `beforeEach` and `afterEach` -> execute code before and after each spec

===== Custom Matchers

Jasmine framework in easily extendable, and it allows you to define your own matchers if for some reasons you're unable to find the appropriate matchers in the Jasmine distribution. In such cases you'd need to write a custom matcher. Let's write matcher that check if string contains name of Secret Agent from the defined list of agents. 

// TBD

.Custom `toBeSecretAgent` matcher
[source,javascript]
----
beforeEach(function () {
    this.addMatchers({
        toBeSecretAgent: function () {
            var agentList = [
                "James Bond",
                "Ethan Hunt",
                "Jason Bourne",
                "Aaron Cross",
                "Jack Reacher"
            ];

            var actual = this.actual;               // <1>
            this.message = function () {            // <2>
                return actual + " is not a secret agent";
            };
            return agentList.indexOf(actual) !== -1;    // <3> 
        }
    });
});
----

<1> `this.actual` contains the value used as arguments in the `expect` function.

<2> We can customize error message if the test fails.

<3> This function checks if `agentsList` contains the actual value.

The invocations of this helper can look like this:

[source,javascript]
----
it("part of super agents", function () {
    expect("James Bond").toBeSecretAgent();         // <1>
    expect("Jason Bourne").toBeSecretAgent();
    expect("Austin Powers").not.toBeSecretAgent();  // <2>
    expect("Austin Powers").toBeSecretAgent();     // <3>
});
----

<1> Calling the custom matcher.

<2> Custom matchers could be used together with `.not` modifier.

<3> This expectation will fail because 'Austin Powers' in not in the list of secret agents.

The following custom failure message will be displayed on the console.
    
[source,bash]
----
/usr/local/share/npm/bin/grunt --gruntfile Gruntfile_jasmine.js jasmine
Running "jasmine:src" (jasmine) task
Testing jasmine specs via phantom
...........x
My function under test should:: part of super agents: failed
  "Austin Powers is not a secret agent (4)"               # <1>
1 specs in 0.115s.
>> 1 failures
Warning: Task "jasmine:src" failed. Use --force to continue.

Aborted due to warnings.
----

<1> A custom failure message. Also, the failed `expect` was the fourth one (4) according to the order mentioned in spec.


===== Spies

// TBD

.Specifications Anatomy TODO
* Write Jasmine specs in test-first manner (write test -> test fail -> write implementation -> test pass -> refactor )

===== BDD Best Practices

TBD...

// <vik>
==== Testing DOM

As you learned in the previous chapters, Document Object Model (DOM) is standard browser API that allows a developer to access and manipulate page elements. As you have seen in previous chapter, most on your JavaScript code needs to access and manipulate the page in some way. Testing the DOM is the crucial part of testing your client side JavaScript. 
By design, DOM is cross-browser API. But in real world, if you want to make sure that your code works on the particular browser you need to run the test inside on your browser.

// </vik>

==== Multi-Browser Testing With Karma

In the previous section of this chapter we showed you how to execute your test and specification in headless mode using PhantomJS, which is very useful for running tests in the Continuous Integration environments. While PhantomJS is based on the WebKit rendering engine, there are browsers that don't use WebKit. It's obvious that running tests manually in each browser is tedious and not productive.

To automate testing in all Web browsers, you can use Karma framework (previously known as _Testacular_). In this section we will show how to configure Karma and integrate it with Grunt.

===== Karma Configuration file

Karma runner is driven by a configuration file.

// TBD

.A Simple Karma Configuration File
----
basePath = '';      // <1>

files = [           // <2>
  JASMINE,
  JASMINE_ADAPTER,
    "app/js/*.js",
    "test/spec/*.js"
];

exclude = [         // <3>
    "app/js/main.js",
    "test/spec/introduction.js"
];

browsers = ['Chrome', 'ChromeCanary', 'PhantomJS', 'Safari', 'Firefox', 'Opera']; // <4>

singleRun = true; //<5>
----
//<vik>
<1> Path that will be used to resolve location of the files <2> and exclude <3>. 
<2> An array of the file names to load in the browser.
<3> An array of the file names to be excluded from loading.
<4> An array of the browser names to be used to execute JavaScript code.
<5> If this property is equals true that Karma will start the browsers, runs the tests and exit.

//<vik>
===== Running Tests 

// TBD

.Gruntfile with karma task
[source,javascript]
----
module.exports = function(grunt) {
  "use strict";  
  grunt.initConfig({
    karma: {                        // <1>
      unit: {
        configFile: 'test/runner/karma_min.conf.js' // <2>
      }
    }
  });
  grunt.loadNpmTasks("grunt-karma");
};
----
<1> TheKarma task is defined in grunt config.
<2> The name of the configuration file for the Karma task.

Now we can run our test simultaneously on all browsers that we have installed in  our computer - Google Chrome (+ Canary version), Safari, Firefox, Opera and PhantomJS - with one command:

`grunt karma`.

// TBD

[source,bash]
----
Running "karma:unit" (karma) task
INFO [karma]: Karma server started at http://localhost:9876/
INFO [launcher]: Starting browser Chrome
INFO [launcher]: Starting browser ChromeCanary
INFO [launcher]: Starting browser PhantomJS
INFO [launcher]: Starting browser Safari
INFO [launcher]: Starting browser Firefox
INFO [launcher]: Starting browser Opera
INFO [Firefox 21.0 (Mac)]: Connected on socket id kfZ_D_dP0eewVOWMx2z4
INFO [Chrome 28.0 (Mac)]: Connected on socket id XYjd5-4l7KrVW1Tbx2z3
INFO [Chrome 27.0 (Mac)]: Connected on socket id t8LWBg5pOW0sj-J0x2z2
INFO [PhantomJS 1.9 (Mac)]: Connected on socket id -_8qltf9e0aGkqE5x2z5
INFO [Safari 6.0 (Mac)]: Connected on socket id M9D2SRAmIvDdiQRcx2z6
INFO [Opera 12.15 (Mac)]: Connected on socket id AMMmGSyUu7j_mkRDx2z7
Firefox 21.0 (Mac): Executed 12 of 12 SUCCESS (0.27 secs / 0.007 secs)
Chrome 28.0 (Mac): Executed 12 of 12 SUCCESS (0.341 secs / 0.02 secs)
Chrome 27.0 (Mac): Executed 12 of 12 SUCCESS (0.34 secs / 0.016 secs)
PhantomJS 1.9 (Mac): Executed 12 of 12 SUCCESS (0.329 secs / 0.012 secs)
Safari 6.0 (Mac): Executed 12 of 12 SUCCESS (0.438 secs / 0.051 secs)
Opera 12.15 (Mac): Executed 12 of 12 SUCCESS (0.662 secs / 0.015 secs)
TOTAL: 72 SUCCESS
----

// TBD


=== Save Sick Child With TDD

TBD...  